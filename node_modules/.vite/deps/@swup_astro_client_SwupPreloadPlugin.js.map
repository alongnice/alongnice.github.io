{
  "version": 3,
  "sources": ["../../.pnpm/@swup+preload-plugin@3.2.10_swup@4.7.0/node_modules/@swup/preload-plugin/src/util.ts", "../../.pnpm/@swup+preload-plugin@3.2.10_swup@4.7.0/node_modules/@swup/preload-plugin/src/index.ts", "../../.pnpm/@swup+preload-plugin@3.2.10_swup@4.7.0/node_modules/@swup/preload-plugin/src/queue.ts", "../../.pnpm/@swup+preload-plugin@3.2.10_swup@4.7.0/node_modules/@swup/preload-plugin/src/observer.ts"],
  "sourcesContent": ["/**\n * Check if the user's connection is configured and fast enough\n * to preload data in the background.\n */\nexport function networkSupportsPreloading(): boolean {\n\tif (navigator.connection) {\n\t\tif (navigator.connection.saveData) {\n\t\t\treturn false;\n\t\t}\n\t\tif (navigator.connection.effectiveType?.endsWith('2g')) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Does this device support true hover/pointer interactions?\n */\nexport function deviceSupportsHover() {\n\treturn window.matchMedia('(hover: hover)').matches;\n}\n\n/**\n * Is this element an anchor element?\n */\nexport function isAnchorElement(element: unknown): element is HTMLAnchorElement | SVGAElement {\n\treturn !!element && (element instanceof HTMLAnchorElement || element instanceof SVGAElement);\n}\n\n/**\n * Safe requestIdleCallback function that falls back to setTimeout\n */\nexport const whenIdle = window.requestIdleCallback || ((cb) => setTimeout(cb, 1));\n", "import Plugin from '@swup/plugin';\nimport { getCurrentUrl, Location } from 'swup';\nimport type {\n\tDelegateEvent,\n\tDelegateEventHandler,\n\tDelegateEventUnsubscribe,\n\tPageData,\n\tHookDefaultHandler\n} from 'swup';\nimport {\n\tdeviceSupportsHover,\n\tnetworkSupportsPreloading,\n\twhenIdle,\n\tisAnchorElement\n} from './util.js';\nimport createQueue, { Queue } from './queue.js';\nimport createObserver, { Observer } from './observer.js';\n\ndeclare module 'swup' {\n\texport interface Swup {\n\t\t/**\n\t\t * Preload links by passing in either:\n\t\t * - a URL or an array of URLs\n\t\t * - a link element or an array of link elements\n\t\t */\n\t\tpreload?: SwupPreloadPlugin['preload'];\n\t\t/**\n\t\t * Preload any links on the current page manually marked for preloading.\n\t\t */\n\t\tpreloadLinks?: () => void;\n\t}\n\texport interface HookDefinitions {\n\t\t'link:hover': { el: HTMLAnchorElement | SVGAElement; event: DelegateEvent };\n\t\t'page:preload': { url: string; page?: PageData };\n\t}\n\texport interface HookReturnValues {\n\t\t'page:preload': Promise<PageData>;\n\t}\n}\n\nexport type AnchorElement = HTMLAnchorElement | SVGAElement;\n\ntype VisibleLinkPreloadOptions = {\n\t/** Enable preloading of links entering the viewport */\n\tenabled: boolean;\n\t/** How much area of a link must be visible to preload it: 0 to 1.0 */\n\tthreshold: number;\n\t/** How long a link must be visible to preload it, in milliseconds */\n\tdelay: number;\n\t/** Containers to look for links in */\n\tcontainers: string[];\n\t/** Callback for opting out selected elements from preloading */\n\tignore: (el: AnchorElement) => boolean;\n};\n\nexport type PluginOptions = {\n\t/** The *concurrency limit* for simultaneous requests when preloading. */\n\tthrottle: number;\n\t/** Preload the initial page to allow instant back-button navigation. */\n\tpreloadInitialPage: boolean;\n\t/** Preload links when they are hovered, touched or focused. */\n\tpreloadHoveredLinks: boolean;\n\t/** Preload links when they enter the viewport. */\n\tpreloadVisibleLinks: VisibleLinkPreloadOptions;\n};\n\nexport type PluginInitOptions = Omit<PluginOptions, 'preloadVisibleLinks'> & {\n\t/** Preload links when they enter the viewport. */\n\tpreloadVisibleLinks: boolean | Partial<VisibleLinkPreloadOptions>;\n};\n\ntype PreloadOptions = {\n\t/** Priority of this preload: `true` for high, `false` for low. */\n\tpriority?: boolean;\n};\n\nexport default class SwupPreloadPlugin extends Plugin {\n\tname = 'SwupPreloadPlugin';\n\n\trequires = { swup: '>=4.5' };\n\n\tdefaults: PluginOptions = {\n\t\tthrottle: 5,\n\t\tpreloadInitialPage: true,\n\t\tpreloadHoveredLinks: true,\n\t\tpreloadVisibleLinks: {\n\t\t\tenabled: false,\n\t\t\tthreshold: 0.2,\n\t\t\tdelay: 500,\n\t\t\tcontainers: ['body'],\n\t\t\tignore: () => false\n\t\t}\n\t};\n\n\toptions: PluginOptions;\n\n\tprotected queue: Queue;\n\tprotected preloadObserver?: Observer;\n\tprotected preloadPromises = new Map<string, Promise<PageData | void>>();\n\n\tprotected mouseEnterDelegate?: DelegateEventUnsubscribe;\n\tprotected touchStartDelegate?: DelegateEventUnsubscribe;\n\tprotected focusDelegate?: DelegateEventUnsubscribe;\n\n\tconstructor(options: Partial<PluginInitOptions> = {}) {\n\t\tsuper();\n\n\t\t// Set all options except `preloadVisibleLinks` which is sanitized below\n\t\tconst { preloadVisibleLinks, ...otherOptions } = options;\n\t\tthis.options = { ...this.defaults, ...otherOptions };\n\n\t\t// Sanitize/merge `preloadVisibleLinks`` option\n\t\tif (typeof preloadVisibleLinks === 'object') {\n\t\t\tthis.options.preloadVisibleLinks = {\n\t\t\t\t...this.options.preloadVisibleLinks,\n\t\t\t\tenabled: true,\n\t\t\t\t...preloadVisibleLinks\n\t\t\t};\n\t\t} else {\n\t\t\tthis.options.preloadVisibleLinks.enabled = Boolean(preloadVisibleLinks);\n\t\t}\n\n\t\t// Bind public methods\n\t\tthis.preload = this.preload.bind(this);\n\n\t\t// Create global priority queue\n\t\tthis.queue = createQueue(this.options.throttle);\n\t}\n\n\tmount() {\n\t\tconst swup = this.swup;\n\n\t\tif (!swup.options.cache) {\n\t\t\tconsole.warn('SwupPreloadPlugin: swup cache needs to be enabled for preloading');\n\t\t\treturn;\n\t\t}\n\n\t\tswup.hooks.create('page:preload');\n\t\tswup.hooks.create('link:hover');\n\n\t\tswup.preload = this.preload;\n\t\tswup.preloadLinks = this.preloadLinks;\n\n\t\t// Inject custom promise whenever a page is loaded\n\t\tthis.replace('page:load', this.onPageLoad);\n\n\t\t// Preload links with [data-swup-preload] attr\n\t\tthis.preloadLinks();\n\t\tthis.on('page:view', () => this.preloadLinks());\n\n\t\t// Preload visible links in viewport\n\t\tif (this.options.preloadVisibleLinks.enabled) {\n\t\t\tthis.preloadVisibleLinks();\n\t\t\tthis.on('page:view', () => this.preloadVisibleLinks());\n\t\t}\n\n\t\t// Preload links on attention\n\t\tif (this.options.preloadHoveredLinks) {\n\t\t\tthis.preloadLinksOnAttention();\n\t\t}\n\n\t\t// Cache unmodified DOM of initial/current page\n\t\tif (this.options.preloadInitialPage) {\n\t\t\tthis.preload(getCurrentUrl());\n\t\t}\n\t}\n\n\tunmount() {\n\t\tthis.swup.preload = undefined;\n\t\tthis.swup.preloadLinks = undefined;\n\n\t\tthis.preloadPromises.clear();\n\n\t\tthis.mouseEnterDelegate?.destroy();\n\t\tthis.touchStartDelegate?.destroy();\n\t\tthis.focusDelegate?.destroy();\n\n\t\tthis.stopPreloadingVisibleLinks();\n\t}\n\n\t/**\n\t * Before core page load: return existing preload promise if available.\n\t */\n\tprotected onPageLoad: HookDefaultHandler<'page:load'> = (visit, args, defaultHandler) => {\n\t\tconst { url } = visit.to;\n\t\tif (url && this.preloadPromises.has(url)) {\n\t\t\treturn this.preloadPromises.get(url) as Promise<PageData>;\n\t\t}\n\t\treturn defaultHandler!(visit, args);\n\t};\n\n\t/**\n\t * When hovering over a link: preload the linked page with high priority.\n\t */\n\tprotected onMouseEnter: DelegateEventHandler = async (event) => {\n\t\t// Make sure mouseenter is only fired once even on links with nested html\n\t\tif (event.target !== event.delegateTarget) return;\n\n\t\t// Return early on devices that don't support hover\n\t\tif (!deviceSupportsHover()) return;\n\n\t\tconst el = event.delegateTarget;\n\t\tif (!isAnchorElement(el)) return;\n\n\t\t// Create temporary visit object for link:hover hook\n\t\tconst { url: to, hash } = Location.fromElement(el);\n\t\t// @ts-expect-error: createVisit is currently private, need to make this semi-public somehow\n\t\tconst visit = this.swup.createVisit({ to, hash, el, event });\n\n\t\tthis.swup.hooks.callSync('link:hover', visit, { el, event });\n\t\tthis.preload(el, { priority: true });\n\t};\n\n\t/**\n\t * When touching a link: preload the linked page with high priority.\n\t */\n\tprotected onTouchStart: DelegateEventHandler = (event) => {\n\t\t// Return early on devices that support hover\n\t\tif (deviceSupportsHover()) return;\n\n\t\tconst el = event.delegateTarget;\n\t\tif (!isAnchorElement(el)) return;\n\n\t\tthis.preload(el, { priority: true });\n\t};\n\n\t/**\n\t * When focussing a link: preload the linked page with high priority.\n\t */\n\tprotected onFocus: DelegateEventHandler = (event) => {\n\t\tconst el = event.delegateTarget;\n\t\tif (!isAnchorElement(el)) return;\n\n\t\tthis.preload(el, { priority: true });\n\t};\n\n\t/**\n\t * Preload links.\n\t *\n\t * The method accepts either:\n\t * - a URL or an array of URLs\n\t * - a link element or an array of link elements\n\t *\n\t * It returns either:\n\t * - a Promise resolving to the page data, if requesting a single page\n\t * - a Promise resolving to an array of page data, if requesting multiple pages\n\t */\n\tasync preload(url: string, options?: PreloadOptions): Promise<PageData | void>;\n\tasync preload(urls: string[], options?: PreloadOptions): Promise<(PageData | void)[]>;\n\tasync preload(el: AnchorElement, options?: PreloadOptions): Promise<PageData | void>;\n\tasync preload(els: AnchorElement[], options?: PreloadOptions): Promise<(PageData | void)[]>;\n\tasync preload(\n\t\tinput: string | AnchorElement,\n\t\toptions?: PreloadOptions\n\t): Promise<PageData | void>;\n\tasync preload(\n\t\tinput: string | string[] | AnchorElement | AnchorElement[],\n\t\toptions: PreloadOptions = {}\n\t): Promise<PageData | (PageData | void)[] | void> {\n\t\tlet url: string;\n\t\tlet el: AnchorElement | undefined;\n\t\tconst priority = options.priority ?? false;\n\n\t\t// Allow passing in array of urls or elements\n\t\tif (Array.isArray(input)) {\n\t\t\treturn Promise.all(input.map((link) => this.preload(link)));\n\t\t}\n\t\t// Allow passing in an anchor element\n\t\telse if (isAnchorElement(input)) {\n\t\t\tel = input;\n\t\t\t({ href: url } = Location.fromElement(input));\n\t\t}\n\t\t// Allow passing in a url\n\t\telse if (typeof input === 'string') {\n\t\t\turl = input;\n\t\t}\n\t\t// Disallow other types\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return if no url passed in\n\t\tif (!url) return;\n\n\t\t// Already preloading? Return existing promise\n\t\tif (this.preloadPromises.has(url)) {\n\t\t\treturn this.preloadPromises.get(url);\n\t\t}\n\n\t\t// Should we preload?\n\t\tif (!this.shouldPreload(url, { el })) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Queue the preload with either low or high priority\n\t\t// The actual preload will happen when a spot in the queue is available\n\t\tconst queuedPromise = new Promise<PageData | void>((resolve) => {\n\t\t\tthis.queue.add(() => {\n\t\t\t\tthis.performPreload(url)\n\t\t\t\t\t.catch(() => {})\n\t\t\t\t\t.then((page) => resolve(page))\n\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\tthis.queue.next();\n\t\t\t\t\t\tthis.preloadPromises.delete(url);\n\t\t\t\t\t});\n\t\t\t}, priority);\n\t\t});\n\n\t\tthis.preloadPromises.set(url, queuedPromise);\n\n\t\treturn queuedPromise;\n\t}\n\n\t/**\n\t * Preload any links on the current page manually marked for preloading.\n\t *\n\t * Links are marked for preloading by:\n\t * - adding a `data-swup-preload` attribute to the link itself\n\t * - adding a `data-swup-preload-all` attribute to a container of multiple links\n\t */\n\tpreloadLinks(): void {\n\t\twhenIdle(() => {\n\t\t\tconst selector = 'a[data-swup-preload], [data-swup-preload-all] a';\n\t\t\tconst links = Array.from(document.querySelectorAll<AnchorElement>(selector));\n\t\t\tlinks.forEach((el) => this.preload(el));\n\t\t});\n\t}\n\n\t/**\n\t * Register handlers for preloading on attention:\n\t *  - mouseenter\n\t *  - touchstart\n\t *  - focus\n\t */\n\tprotected preloadLinksOnAttention() {\n\t\tconst { swup } = this;\n\n\t\tconst { linkSelector: selector } = swup.options;\n\t\tconst opts = { passive: true, capture: true };\n\t\tthis.mouseEnterDelegate = swup.delegateEvent(\n\t\t\tselector,\n\t\t\t'mouseenter',\n\t\t\tthis.onMouseEnter,\n\t\t\topts\n\t\t);\n\t\tthis.touchStartDelegate = swup.delegateEvent(\n\t\t\tselector,\n\t\t\t'touchstart',\n\t\t\tthis.onTouchStart,\n\t\t\topts\n\t\t);\n\t\tthis.focusDelegate = swup.delegateEvent(selector, 'focus', this.onFocus, opts);\n\t}\n\n\t/**\n\t * Start observing links in the viewport for preloading.\n\t * Calling this repeatedly re-checks for links after DOM updates.\n\t */\n\tprotected preloadVisibleLinks(): void {\n\t\t// Scan DOM for new links on repeated calls\n\t\tif (this.preloadObserver) {\n\t\t\tthis.preloadObserver.update();\n\t\t\treturn;\n\t\t}\n\n\t\tconst { threshold, delay, containers } = this.options.preloadVisibleLinks;\n\t\tconst callback = (el: AnchorElement) => this.preload(el);\n\t\tconst filter = (el: AnchorElement) => {\n\t\t\t/** First, run the custom callback */\n\t\t\tif (this.options.preloadVisibleLinks.ignore(el)) return false;\n\t\t\t/** Second, check if it's a valid swup link */\n\t\t\tif (!el.matches(this.swup.options.linkSelector)) return false;\n\t\t\t/** Third, run all default checks */\n\t\t\tconst { href } = Location.fromElement(el);\n\t\t\treturn this.shouldPreload(href, { el });\n\t\t};\n\n\t\tthis.preloadObserver = createObserver({ threshold, delay, containers, callback, filter });\n\t\tthis.preloadObserver.start();\n\t}\n\n\t/**\n\t * Stop observing links in the viewport for preloading.\n\t */\n\tprotected stopPreloadingVisibleLinks(): void {\n\t\tif (this.preloadObserver) {\n\t\t\tthis.preloadObserver.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Check whether a URL and/or element should trigger a preload.\n\t */\n\tprotected shouldPreload(location: string, { el }: { el?: AnchorElement } = {}): boolean {\n\t\tconst { url, href } = Location.fromUrl(location);\n\n\t\t// Network too slow?\n\t\tif (!networkSupportsPreloading()) return false;\n\t\t// Already in cache?\n\t\tif (this.swup.cache.has(url)) return false;\n\t\t// Already preloading?\n\t\tif (this.preloadPromises.has(url)) return false;\n\t\t// Should be ignored anyway?\n\t\tif (this.swup.shouldIgnoreVisit(href, { el })) return false;\n\t\t// Special condition for links: points to current page?\n\t\tif (el && this.swup.resolveUrl(url) === this.swup.resolveUrl(getCurrentUrl())) return false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Perform the actual preload fetch and trigger the preload hook.\n\t */\n\tprotected async performPreload(href: string): Promise<PageData> {\n\t\tconst { url } = Location.fromUrl(href);\n\n\t\t// Create temporary visit object for page:preload hook\n\t\t// @ts-expect-error: createVisit is currently private, need to make this semi-public somehow\n\t\tconst visit = this.swup.createVisit({ to: url });\n\n\t\tconst page = await this.swup.hooks.call(\n\t\t\t'page:preload',\n\t\t\tvisit,\n\t\t\t{ url },\n\t\t\tasync (visit, args) => {\n\t\t\t\t// @ts-expect-error FetchOptions.visit is currently marked as internal\n\t\t\t\targs.page = await this.swup.fetchPage(href, { visit });\n\t\t\t\treturn args.page;\n\t\t\t}\n\t\t);\n\t\treturn page;\n\t}\n}\n", "type QueueFunction = {\n\t(): void;\n\t__queued?: boolean;\n};\n\nexport type Queue = {\n\tadd: (fn: QueueFunction, highPriority?: boolean) => void;\n\tnext: () => void;\n};\n\nexport default function createQueue(limit: number = 1): Queue {\n\tconst qlow: QueueFunction[] = [];\n\tconst qhigh: QueueFunction[] = [];\n\tlet total = 0;\n\tlet running = 0;\n\n\tfunction add(fn: QueueFunction, highPriority: boolean = false): void {\n\t\t// Already added before?\n\t\tif (fn.__queued) {\n\t\t\t// Move from low to high-priority queue\n\t\t\tif (highPriority) {\n\t\t\t\tconst idx = qlow.indexOf(fn);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tconst removed = qlow.splice(idx, 1);\n\t\t\t\t\ttotal = total - removed.length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Mark as processed\n\t\tfn.__queued = true;\n\t\t// Push to queue: high or low\n\t\t(highPriority ? qhigh : qlow).push(fn);\n\t\t// Increment total\n\t\ttotal++;\n\t\t// Initialize queue if first item\n\t\tif (total <= 1) {\n\t\t\trun();\n\t\t}\n\t}\n\n\tfunction next(): void {\n\t\trunning--; // make room for next\n\t\trun();\n\t}\n\n\tfunction run(): void {\n\t\tif (running < limit && total > 0) {\n\t\t\tconst fn = qhigh.shift() || qlow.shift() || (() => {});\n\t\t\tfn();\n\t\t\ttotal--;\n\t\t\trunning++; // is now WIP\n\t\t}\n\t}\n\n\treturn { add, next };\n}\n", "import { Location } from 'swup';\n\nimport { AnchorElement } from './index.js';\nimport { whenIdle } from './util.js';\n\nexport type Observer = {\n\tstart: () => void;\n\tstop: () => void;\n\tupdate: () => void;\n};\n\nexport default function createObserver({\n\tthreshold,\n\tdelay,\n\tcontainers,\n\tcallback,\n\tfilter\n}: {\n\tthreshold: number;\n\tdelay: number;\n\tcontainers: string[];\n\tcallback: (el: AnchorElement) => void;\n\tfilter: (el: AnchorElement) => boolean;\n}): Observer {\n\tconst visibleLinks = new Map<string, Set<AnchorElement>>();\n\n\t// Create an observer to add/remove links when they enter the viewport\n\tconst observer = new IntersectionObserver(\n\t\t(entries) => {\n\t\t\tentries.forEach((entry) => {\n\t\t\t\tif (entry.isIntersecting) {\n\t\t\t\t\tadd(entry.target as AnchorElement);\n\t\t\t\t} else {\n\t\t\t\t\tremove(entry.target as AnchorElement);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t{ threshold }\n\t);\n\n\t// Preload link if it is still visible after a configurable timeout\n\tconst add = (el: AnchorElement) => {\n\t\tconst { href } = Location.fromElement(el);\n\t\tconst elements = visibleLinks.get(href) ?? new Set();\n\t\tvisibleLinks.set(href, elements);\n\t\telements.add(el);\n\n\t\tsetTimeout(() => {\n\t\t\tconst elements = visibleLinks.get(href);\n\t\t\tif (elements?.size) {\n\t\t\t\tcallback(el);\n\t\t\t\tobserver.unobserve(el);\n\t\t\t\telements.delete(el);\n\t\t\t}\n\t\t}, delay);\n\t};\n\n\t// Remove link from list of visible links\n\tconst remove = (el: AnchorElement) => {\n\t\tconst { href } = Location.fromElement(el);\n\t\tvisibleLinks.get(href)?.delete(el);\n\t};\n\n\t// Clear list of visible links\n\tconst clear = () => visibleLinks.clear();\n\n\t// Scan DOM for preloadable links and start observing their visibility\n\tconst observe = () => {\n\t\twhenIdle(() => {\n\t\t\tconst selector = containers.map((root) => `${root} a[*|href]`).join(', ');\n\t\t\tconst links = Array.from(document.querySelectorAll<AnchorElement>(selector));\n\t\t\tlinks.filter((el) => filter(el)).forEach((el) => observer.observe(el));\n\t\t});\n\t};\n\n\treturn {\n\t\tstart: () => observe(),\n\t\tstop: () => observer.disconnect(),\n\t\tupdate: () => (clear(), observe())\n\t};\n}\n"],
  "mappings": "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",
  "names": ["deviceSupportsHover", "window", "matchMedia", "matches", "isAnchorElement", "element", "HTMLAnchorElement", "SVGAElement", "whenIdle", "requestIdleCallback", "cb", "setTimeout", "_excluded", "SwupPreloadPlugin", "Plugin", "constructor", "options", "_this", "super", "this", "name", "requires", "swup", "defaults", "throttle", "preloadInitialPage", "preloadHoveredLinks", "preloadVisibleLinks", "enabled", "threshold", "delay", "containers", "ignore", "queue", "preloadObserver", "preloadPromises", "Map", "mouseEnterDelegate", "touchStartDelegate", "focusDelegate", "onPageLoad", "visit", "args", "defaultHandler", "url", "to", "has", "get", "onMouseEnter", "async", "event", "target", "delegateTarget", "el", "hash", "Location", "fromElement", "createVisit", "hooks", "callSync", "preload", "priority", "onTouchStart", "onFocus", "otherOptions", "_extends", "Boolean", "bind", "limit", "qlow", "qhigh", "total", "running", "run", "shift", "add", "fn", "highPriority", "__queued", "idx", "indexOf", "removed", "splice", "length", "push", "next", "mount", "cache", "create", "preloadLinks", "replace", "on", "preloadLinksOnAttention", "getCurrentUrl", "console", "warn", "unmount", "_this$mouseEnterDeleg", "_this$touchStartDeleg", "_this$focusDelegate", "clear", "destroy", "stopPreloadingVisibleLinks", "input", "_options$priority", "Array", "isArray", "Promise", "all", "map", "link", "href", "shouldPreload", "queuedPromise", "resolve", "performPreload", "catch", "then", "page", "finally", "delete", "set", "from", "document", "querySelectorAll", "forEach", "linkSelector", "selector", "opts", "passive", "capture", "delegateEvent", "update", "callback", "filter", "visibleLinks", "observer", "IntersectionObserver", "entries", "entry", "isIntersecting", "remove", "_visibleLinks$get", "elements", "Set", "size", "unobserve", "_visibleLinks$get2", "observe", "root", "join", "start", "stop", "disconnect", "location", "fromUrl", "navigator", "connection", "_navigator$connection", "saveData", "effectiveType", "endsWith", "networkSupportsPreloading", "shouldIgnoreVisit", "resolveUrl", "_this2", "call", "fetchPage"]
}
