import {
  l,
  n
} from "./chunk-4G7MLUAF.js";
import {
  e
} from "./chunk-RU6KZPHD.js";
import "./chunk-EQCVQC35.js";

// node_modules/.pnpm/@swup+preload-plugin@3.2.10_swup@4.7.0/node_modules/@swup/preload-plugin/dist/index.modern.js
function r() {
  return r = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t = 1; t < arguments.length; t++) {
      var s = arguments[t];
      for (var r2 in s) Object.prototype.hasOwnProperty.call(s, r2) && (e2[r2] = s[r2]);
    }
    return e2;
  }, r.apply(this, arguments);
}
function o() {
  return window.matchMedia("(hover: hover)").matches;
}
function i(e2) {
  return !!e2 && (e2 instanceof HTMLAnchorElement || e2 instanceof SVGAElement);
}
var n2 = window.requestIdleCallback || ((e2) => setTimeout(e2, 1));
var a = ["preloadVisibleLinks"];
var l2 = class extends e {
  constructor(e2 = {}) {
    var s;
    super(), s = this, this.name = "SwupPreloadPlugin", this.requires = { swup: ">=4.5" }, this.defaults = { throttle: 5, preloadInitialPage: true, preloadHoveredLinks: true, preloadVisibleLinks: { enabled: false, threshold: 0.2, delay: 500, containers: ["body"], ignore: () => false } }, this.options = void 0, this.queue = void 0, this.preloadObserver = void 0, this.preloadPromises = /* @__PURE__ */ new Map(), this.mouseEnterDelegate = void 0, this.touchStartDelegate = void 0, this.focusDelegate = void 0, this.onPageLoad = (e3, t, s2) => {
      const { url: r2 } = e3.to;
      return r2 && this.preloadPromises.has(r2) ? this.preloadPromises.get(r2) : s2(e3, t);
    }, this.onMouseEnter = async function(e3) {
      if (e3.target !== e3.delegateTarget) return;
      if (!o()) return;
      const r2 = e3.delegateTarget;
      if (!i(r2)) return;
      const { url: n4, hash: a2 } = l.fromElement(r2), l4 = s.swup.createVisit({ to: n4, hash: a2, el: r2, event: e3 });
      s.swup.hooks.callSync("link:hover", l4, { el: r2, event: e3 }), s.preload(r2, { priority: true });
    }, this.onTouchStart = (e3) => {
      if (o()) return;
      const t = e3.delegateTarget;
      i(t) && this.preload(t, { priority: true });
    }, this.onFocus = (e3) => {
      const t = e3.delegateTarget;
      i(t) && this.preload(t, { priority: true });
    };
    const { preloadVisibleLinks: n3 } = e2, l3 = function(e3, t) {
      if (null == e3) return {};
      var s2, r2, o2 = {}, i2 = Object.keys(e3);
      for (r2 = 0; r2 < i2.length; r2++) t.indexOf(s2 = i2[r2]) >= 0 || (o2[s2] = e3[s2]);
      return o2;
    }(e2, a);
    this.options = r({}, this.defaults, l3), "object" == typeof n3 ? this.options.preloadVisibleLinks = r({}, this.options.preloadVisibleLinks, { enabled: true }, n3) : this.options.preloadVisibleLinks.enabled = Boolean(n3), this.preload = this.preload.bind(this), this.queue = /* @__PURE__ */ function(e3 = 1) {
      const t = [], s2 = [];
      let r2 = 0, o2 = 0;
      function i2() {
        o2 < e3 && r2 > 0 && ((s2.shift() || t.shift() || (() => {
        }))(), r2--, o2++);
      }
      return { add: function(e4, o3 = false) {
        if (e4.__queued) {
          if (!o3) return;
          {
            const s3 = t.indexOf(e4);
            if (s3 >= 0) {
              const e5 = t.splice(s3, 1);
              r2 -= e5.length;
            }
          }
        }
        e4.__queued = true, (o3 ? s2 : t).push(e4), r2++, r2 <= 1 && i2();
      }, next: function() {
        o2--, i2();
      } };
    }(this.options.throttle);
  }
  mount() {
    const e2 = this.swup;
    e2.options.cache ? (e2.hooks.create("page:preload"), e2.hooks.create("link:hover"), e2.preload = this.preload, e2.preloadLinks = this.preloadLinks, this.replace("page:load", this.onPageLoad), this.preloadLinks(), this.on("page:view", () => this.preloadLinks()), this.options.preloadVisibleLinks.enabled && (this.preloadVisibleLinks(), this.on("page:view", () => this.preloadVisibleLinks())), this.options.preloadHoveredLinks && this.preloadLinksOnAttention(), this.options.preloadInitialPage && this.preload(n())) : console.warn("SwupPreloadPlugin: swup cache needs to be enabled for preloading");
  }
  unmount() {
    var e2, t, s;
    this.swup.preload = void 0, this.swup.preloadLinks = void 0, this.preloadPromises.clear(), null == (e2 = this.mouseEnterDelegate) || e2.destroy(), null == (t = this.touchStartDelegate) || t.destroy(), null == (s = this.focusDelegate) || s.destroy(), this.stopPreloadingVisibleLinks();
  }
  async preload(e2, s = {}) {
    var r2;
    let o2, n3;
    const a2 = null != (r2 = s.priority) && r2;
    if (Array.isArray(e2)) return Promise.all(e2.map((e3) => this.preload(e3)));
    if (i(e2)) n3 = e2, { href: o2 } = l.fromElement(e2);
    else {
      if ("string" != typeof e2) return;
      o2 = e2;
    }
    if (!o2) return;
    if (this.preloadPromises.has(o2)) return this.preloadPromises.get(o2);
    if (!this.shouldPreload(o2, { el: n3 })) return;
    const l3 = new Promise((e3) => {
      this.queue.add(() => {
        this.performPreload(o2).catch(() => {
        }).then((t) => e3(t)).finally(() => {
          this.queue.next(), this.preloadPromises.delete(o2);
        });
      }, a2);
    });
    return this.preloadPromises.set(o2, l3), l3;
  }
  preloadLinks() {
    n2(() => {
      Array.from(document.querySelectorAll("a[data-swup-preload], [data-swup-preload-all] a")).forEach((e2) => this.preload(e2));
    });
  }
  preloadLinksOnAttention() {
    const { swup: e2 } = this, { linkSelector: t } = e2.options, s = { passive: true, capture: true };
    this.mouseEnterDelegate = e2.delegateEvent(t, "mouseenter", this.onMouseEnter, s), this.touchStartDelegate = e2.delegateEvent(t, "touchstart", this.onTouchStart, s), this.focusDelegate = e2.delegateEvent(t, "focus", this.onFocus, s);
  }
  preloadVisibleLinks() {
    if (this.preloadObserver) return void this.preloadObserver.update();
    const { threshold: e2, delay: s, containers: r2 } = this.options.preloadVisibleLinks;
    this.preloadObserver = function({ threshold: e3, delay: s2, containers: r3, callback: o2, filter: i2 }) {
      const a2 = /* @__PURE__ */ new Map(), l3 = new IntersectionObserver((e4) => {
        e4.forEach((e5) => {
          e5.isIntersecting ? h(e5.target) : d(e5.target);
        });
      }, { threshold: e3 }), h = (e4) => {
        var r4;
        const { href: i3 } = l.fromElement(e4), n3 = null != (r4 = a2.get(i3)) ? r4 : /* @__PURE__ */ new Set();
        a2.set(i3, n3), n3.add(e4), setTimeout(() => {
          const t = a2.get(i3);
          null != t && t.size && (o2(e4), l3.unobserve(e4), t.delete(e4));
        }, s2);
      }, d = (e4) => {
        var s3;
        const { href: r4 } = l.fromElement(e4);
        null == (s3 = a2.get(r4)) || s3.delete(e4);
      }, u = () => {
        n2(() => {
          const e4 = r3.map((e5) => `${e5} a[*|href]`).join(", ");
          Array.from(document.querySelectorAll(e4)).filter((e5) => i2(e5)).forEach((e5) => l3.observe(e5));
        });
      };
      return { start: () => u(), stop: () => l3.disconnect(), update: () => (a2.clear(), u()) };
    }({ threshold: e2, delay: s, containers: r2, callback: (e3) => this.preload(e3), filter: (e3) => {
      if (this.options.preloadVisibleLinks.ignore(e3)) return false;
      if (!e3.matches(this.swup.options.linkSelector)) return false;
      const { href: s2 } = l.fromElement(e3);
      return this.shouldPreload(s2, { el: e3 });
    } }), this.preloadObserver.start();
  }
  stopPreloadingVisibleLinks() {
    this.preloadObserver && this.preloadObserver.stop();
  }
  shouldPreload(e2, { el: r2 } = {}) {
    const { url: o2, href: i2 } = l.fromUrl(e2);
    return !(!function() {
      if (navigator.connection) {
        var e3;
        if (navigator.connection.saveData) return false;
        if (null != (e3 = navigator.connection.effectiveType) && e3.endsWith("2g")) return false;
      }
      return true;
    }() || this.swup.cache.has(o2) || this.preloadPromises.has(o2) || this.swup.shouldIgnoreVisit(i2, { el: r2 }) || r2 && this.swup.resolveUrl(o2) === this.swup.resolveUrl(n()));
  }
  async performPreload(e2) {
    var s = this;
    const { url: r2 } = l.fromUrl(e2), o2 = this.swup.createVisit({ to: r2 }), i2 = await this.swup.hooks.call("page:preload", o2, { url: r2 }, async function(t, r3) {
      return r3.page = await s.swup.fetchPage(e2, { visit: t }), r3.page;
    });
    return i2;
  }
};
export {
  l2 as default
};
//# sourceMappingURL=@swup_astro_client_SwupPreloadPlugin.js.map
