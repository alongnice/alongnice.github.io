{
  "version": 3,
  "sources": ["../../.pnpm/scrl@2.0.0/node_modules/scrl/src/index.js", "../../.pnpm/@swup+scroll-plugin@3.3.2_swup@4.7.0/node_modules/@swup/scroll-plugin/src/index.ts"],
  "sourcesContent": ["export default class Scrl {\n    _raf = null;\n    _positionY = 0;\n    _velocityY = 0;\n    _targetPositionY = 0;\n    _targetPositionYWithOffset = 0;\n    _direction = 0;\n\n    constructor(options) {\n        // default options\n        const defaults = {\n            onAlreadyAtPositions: () => {},\n            onCancel: () => {},\n            onEnd: () => {},\n            onStart: () => {},\n            onTick: () => {},\n            friction: .7, // 1 - .3\n            acceleration: .04,\n        }\n\n        // merge options\n        this.options = {\n            ...defaults,\n            ...options,\n        };\n\n        // set reverse friction\n        if (options && options.friction) {\n            this.options.friction = 1 - options.friction;\n        }\n\n        // register listener for cancel on wheel event\n        window.addEventListener('mousewheel', event => {\n            if (this._raf) {\n                this.options.onCancel();\n                cancelAnimationFrame(this._raf);\n                this._raf = null;\n            }\n        }, {\n            passive: true\n        });\n    }\n\n    scrollTo = (offset) => {\n        if (offset && offset.nodeType) {\n            // the offset is element\n            this._targetPositionY = Math.round(offset.getBoundingClientRect().top + window.pageYOffset);\n        } else if (parseInt(this._targetPositionY) === this._targetPositionY) {\n            // the offset is a number\n            this._targetPositionY = Math.round(offset);\n        } else {\n            console.error('Argument must be a number or an element.');\n            return;\n        }\n\n        // don't animate beyond the document height\n        if (this._targetPositionY > document.documentElement.scrollHeight - window.innerHeight) {\n            this._targetPositionY = document.documentElement.scrollHeight - window.innerHeight;\n        }\n\n        // calculated required values\n        this._positionY = document.body.scrollTop || document.documentElement.scrollTop;\n        this._direction = (this._positionY > this._targetPositionY) ? -1 : 1;\n        this._targetPositionYWithOffset = this._targetPositionY + this._direction;\n        this._velocityY = 0;\n\n        if (this._positionY !== this._targetPositionY) {\n            // start animation\n            this.options.onStart();\n            this._animate();\n        } else {\n            // page is already at the position\n            this.options.onAlreadyAtPositions();\n        }\n    };\n\n    _animate = () => {\n        const distance = this._update();\n        this._render();\n\n        if (this._direction === 1 && this._targetPositionY > this._positionY || this._direction === -1 && this._targetPositionY < this._positionY) {\n            // calculate next position\n            this._raf = requestAnimationFrame(this._animate);\n            this.options.onTick();\n        } else {\n            // finish and set position to the final position\n            this._positionY = this._targetPositionY;\n            this._render();\n            this._raf = null;\n            this.options.onTick();\n            this.options.onEnd();\n            // this.triggerEvent('scrollDone')\n        }\n    };\n\n    _update = () => {\n        const distance = this._targetPositionYWithOffset - this._positionY;\n        const attraction = distance * this.options.acceleration;\n\n        this._velocityY += attraction;\n\n        this._velocityY *= this.options.friction;\n        this._positionY += this._velocityY;\n\n        return Math.abs(distance);\n    };\n\n    _render = () => {\n        window.scrollTo(0, this._positionY);\n    };\n}\n", "import Plugin from '@swup/plugin';\nimport { Handler, Visit, queryAll } from 'swup';\n// @ts-expect-error\nimport Scrl from 'scrl';\n\nexport type Options = {\n\tdoScrollingRightAway: boolean;\n\tanimateScroll: {\n\t\tbetweenPages: boolean;\n\t\tsamePageWithHash: boolean;\n\t\tsamePage: boolean;\n\t};\n\tscrollFriction: number;\n\tscrollAcceleration: number;\n\tgetAnchorElement?: (hash: string) => Element | null;\n\toffset: number | ((el: Element) => number);\n\tscrollContainers: `[data-swup-scroll-container]`;\n\tshouldResetScrollPosition: (trigger: Element) => boolean;\n\tmarkScrollTarget?: boolean;\n};\n\ntype ScrollPosition = {\n\ttop: number;\n\tleft: number;\n};\n\ntype ScrollPositionsCacheEntry = {\n\twindow: ScrollPosition;\n\tcontainers: ScrollPosition[];\n};\n\ntype ScrollPositionsCache = Record<string, ScrollPositionsCacheEntry>;\n\ndeclare module 'swup' {\n\texport interface Swup {\n\t\tscrollTo?: (offset: number, animate?: boolean) => void;\n\t}\n\n\texport interface VisitScroll {\n\t\t/** Whether scrolling is animated. Set by Scroll Plugin. */\n\t\tanimate?: boolean;\n\t\t/** Whether the scroll position was reset after page load. Set by Scroll Plugin. */\n\t\tscrolledToContent?: boolean;\n\t}\n\n\texport interface HookDefinitions {\n\t\t'scroll:start': undefined;\n\t\t'scroll:end': undefined;\n\t}\n}\n\n/**\n * Scroll Plugin\n */\nexport default class SwupScrollPlugin extends Plugin {\n\tname = 'SwupScrollPlugin';\n\n\trequires = { swup: '>=4.2.0' };\n\n\tscrl: any;\n\n\tdefaults: Options = {\n\t\tdoScrollingRightAway: false,\n\t\tanimateScroll: {\n\t\t\tbetweenPages: true,\n\t\t\tsamePageWithHash: true,\n\t\t\tsamePage: true\n\t\t},\n\t\tscrollFriction: 0.3,\n\t\tscrollAcceleration: 0.04,\n\t\tgetAnchorElement: undefined,\n\t\toffset: 0,\n\t\tscrollContainers: `[data-swup-scroll-container]`,\n\t\tshouldResetScrollPosition: () => true,\n\t\tmarkScrollTarget: false\n\t};\n\n\toptions: Options;\n\n\tcachedScrollPositions: ScrollPositionsCache = {};\n\tpreviousScrollRestoration?: ScrollRestoration;\n\tcurrentCacheKey?: string;\n\n\tconstructor(options: Partial<Options> = {}) {\n\t\tsuper();\n\t\tthis.options = { ...this.defaults, ...options };\n\t}\n\n\tmount() {\n\t\tconst swup = this.swup;\n\n\t\tswup.hooks.create('scroll:start');\n\t\tswup.hooks.create('scroll:end');\n\n\t\t// @ts-expect-error: createVisit is currently private, need to make this semi-public somehow\n\t\tconst visit = this.swup.createVisit({ to: this.swup.currentPageUrl });\n\n\t\t// Initialize Scrl lib for smooth animations\n\t\tthis.scrl = new Scrl({\n\t\t\tonStart: () => swup.hooks.callSync('scroll:start', visit, undefined),\n\t\t\tonEnd: () => swup.hooks.callSync('scroll:end', visit, undefined),\n\t\t\tonCancel: () => swup.hooks.callSync('scroll:end', visit, undefined),\n\t\t\tfriction: this.options.scrollFriction,\n\t\t\tacceleration: this.options.scrollAcceleration\n\t\t});\n\n\t\t// Add scrollTo method to swup and animate based on current animateScroll option\n\t\tswup.scrollTo = (offset, animate = true) => {\n\t\t\tif (animate) {\n\t\t\t\tthis.scrl.scrollTo(offset);\n\t\t\t} else {\n\t\t\t\tswup.hooks.callSync('scroll:start', visit, undefined);\n\t\t\t\twindow.scrollTo(0, offset);\n\t\t\t\tswup.hooks.callSync('scroll:end', visit, undefined);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Disable browser scroll restoration for history visits\n\t\t * if `swup.options.animateHistoryBrowsing` is true\n\t\t * Store the previous setting to be able to properly restore it on unmount\n\t\t */\n\t\tthis.previousScrollRestoration = window.history.scrollRestoration;\n\t\tif (swup.options.animateHistoryBrowsing) {\n\t\t\twindow.history.scrollRestoration = 'manual';\n\t\t}\n\n\t\t/**\n\t\t * Mark the current scroll target element with a `data-swup-scroll-target` attribute\n\t\t */\n\t\tthis.updateScrollTarget = this.updateScrollTarget.bind(this);\n\t\tif (this.options.markScrollTarget) {\n\t\t\twindow.addEventListener('popstate', this.updateScrollTarget);\n\t\t\twindow.addEventListener('hashchange', this.updateScrollTarget);\n\t\t\tthis.on('page:view', this.updateScrollTarget);\n\t\t\tthis.on('link:anchor', this.updateScrollTarget);\n\t\t\tthis.on('link:self', this.updateScrollTarget);\n\t\t\tthis.updateScrollTarget();\n\t\t}\n\n\t\t// scroll to the top of the page when a visit starts, before replacing the content\n\t\tthis.before('visit:start', this.onBeforeVisitStart, { priority: -1 });\n\t\tthis.on('visit:start', this.onVisitStart, { priority: 1 });\n\n\t\t// scroll to the top or target element after replacing the content\n\t\tthis.replace('content:scroll', this.handleScrollToContent);\n\n\t\t// scroll to the top of the same page\n\t\tthis.before('link:self', this.onBeforeLinkToSelf, { priority: -1 });\n\t\tthis.replace('scroll:top', this.handleScrollToTop);\n\n\t\t// scroll to an anchor on the same page\n\t\tthis.before('link:anchor', this.onBeforeLinkToAnchor, { priority: -1 });\n\t\tthis.replace('scroll:anchor', this.handleScrollToAnchor);\n\t}\n\n\t/**\n\t * Runs when the plugin is unmounted\n\t */\n\tunmount() {\n\t\tsuper.unmount();\n\n\t\tif (this.previousScrollRestoration) {\n\t\t\twindow.history.scrollRestoration = this.previousScrollRestoration;\n\t\t}\n\n\t\twindow.removeEventListener('popstate', this.updateScrollTarget);\n\t\twindow.removeEventListener('hashchange', this.updateScrollTarget);\n\n\t\tthis.cachedScrollPositions = {};\n\t\tdelete this.swup.scrollTo;\n\t\tdelete this.scrl;\n\t}\n\n\t/**\n\t * Detects if a scroll should be animated, based on context\n\t */\n\tshouldAnimate(context: keyof Options['animateScroll']): boolean {\n\t\tif (typeof this.options.animateScroll === 'boolean') {\n\t\t\treturn this.options.animateScroll;\n\t\t}\n\t\treturn this.options.animateScroll[context];\n\t}\n\n\t/**\n\t * Get an element based on anchor\n\t */\n\tgetAnchorElement = (hash: string = ''): Element | null => {\n\t\t// Look for a custom function provided via the plugin options\n\t\tif (typeof this.options.getAnchorElement === 'function') {\n\t\t\treturn this.options.getAnchorElement(hash);\n\t\t}\n\n\t\treturn this.swup.getAnchorElement(hash);\n\t};\n\n\t/**\n\t * Get the offset for a scroll\n\t */\n\tgetOffset = (el?: Element): number => {\n\t\tif (!el) return 0;\n\t\t// If options.offset is a function, apply and return it\n\t\tif (typeof this.options.offset === 'function') {\n\t\t\treturn parseInt(String(this.options.offset(el)), 10);\n\t\t}\n\t\t// Otherwise, return the sanitized offset\n\t\treturn parseInt(String(this.options.offset), 10);\n\t};\n\n\t/**\n\t * Store scroll animation status in visit object before scrolling up\n\t */\n\tonBeforeLinkToSelf: Handler<'link:self'> = (visit) => {\n\t\tvisit.scroll.animate = this.shouldAnimate('samePage');\n\t};\n\n\t/**\n\t * Scroll to top on `scroll:top` hook\n\t */\n\thandleScrollToTop: Handler<'scroll:top'> = (visit) => {\n\t\tthis.swup.scrollTo?.(0, visit.scroll.animate);\n\t\treturn true;\n\t};\n\n\t/**\n\t * Store scroll animation status in visit object before scrolling to anchor\n\t */\n\tonBeforeLinkToAnchor: Handler<'link:anchor'> = (visit) => {\n\t\tvisit.scroll.animate = this.shouldAnimate('samePageWithHash');\n\t};\n\n\t/**\n\t * Scroll to anchor on `scroll:anchor` hook\n\t */\n\thandleScrollToAnchor: Handler<'scroll:anchor'> = (visit, { hash }) => {\n\t\treturn this.maybeScrollToAnchor(hash, visit.scroll.animate);\n\t};\n\n\t/**\n\t * Attempts to scroll to an anchor\n\t */\n\tmaybeScrollToAnchor(hash?: string, animate: boolean = false): boolean {\n\t\tif (!hash) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst element = this.getAnchorElement(hash);\n\t\tif (!element) {\n\t\t\tconsole.warn(`Anchor target ${hash} not found`);\n\t\t\treturn false;\n\t\t}\n\t\tif (!(element instanceof Element)) {\n\t\t\tconsole.warn(`Anchor target ${hash} is not a DOM node`);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { top: elementTop } = element.getBoundingClientRect();\n\t\tconst top = elementTop + window.scrollY - this.getOffset(element);\n\t\tthis.swup.scrollTo?.(top, animate);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Prepare scrolling before visit:start hook\n\t */\n\tonBeforeVisitStart: Handler<'visit:start'> = (visit) => {\n\t\tvisit.scroll.scrolledToContent = false;\n\t\tvisit.scroll.animate = this.shouldAnimate('betweenPages');\n\t};\n\n\t/**\n\t * Check whether to scroll in `visit:start` hook\n\t */\n\tonVisitStart: Handler<'visit:start'> = (visit) => {\n\t\tthis.cacheScrollPositions(visit.from.url);\n\t\tthis.maybeResetScrollPositions(visit);\n\n\t\tconst scrollTarget = visit.scroll.target ?? visit.to.hash;\n\n\t\t// Conditions for scrolling before content replace:\n\t\t// - scroll is animated (otherwise the effect is useless)\n\t\t// - no scroll target is defined (needs to wait until new content is there)\n\t\tif (visit.scroll.animate && this.options.doScrollingRightAway && !scrollTarget) {\n\t\t\tthis.doScrollingBetweenPages(visit);\n\t\t}\n\t};\n\n\t/**\n\t * Check whether to scroll in `content:scroll` hook\n\t */\n\thandleScrollToContent: Handler<'content:scroll'> = (visit) => {\n\t\tif (!visit.scroll.scrolledToContent) {\n\t\t\tthis.doScrollingBetweenPages(visit);\n\t\t}\n\t\tthis.restoreScrollContainers(visit.to.url);\n\t};\n\n\t/**\n\t * Scrolls the window\n\t */\n\tdoScrollingBetweenPages = (visit: Visit): void => {\n\t\t// Bail early on popstate if not animated: browser will handle it\n\t\tif (visit.history.popstate && !visit.animation.animate) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Try scrolling to a given anchor\n\t\tconst scrollTarget = visit.scroll.target ?? visit.to.hash;\n\t\tif (scrollTarget && this.maybeScrollToAnchor(scrollTarget, visit.scroll.animate)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Allow not resetting scroll position\n\t\tif (!visit.scroll.reset) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Finally, scroll to either the stored scroll position or to the very top of the page\n\t\tconst scrollPositions = this.getCachedScrollPositions(visit.to.url);\n\t\tconst top = scrollPositions?.window?.top || 0;\n\n\t\t// Give possible JavaScript time to execute before scrolling\n\t\trequestAnimationFrame(() => this.swup.scrollTo?.(top, visit.scroll.animate));\n\n\t\tvisit.scroll.scrolledToContent = true;\n\t};\n\n\t/**\n\t * Reset cached scroll positions. Do not reset if:\n\t * - the visit is a history visit\n\t * - the visit is triggered by a link and shouldResetScrollPosition(link) returns false\n\t */\n\tmaybeResetScrollPositions = (visit: Visit): void => {\n\t\tconst { popstate } = visit.history;\n\t\tconst { url } = visit.to;\n\t\tconst { el } = visit.trigger;\n\t\tif (popstate) {\n\t\t\treturn;\n\t\t}\n\t\tif (el && !this.options.shouldResetScrollPosition(el)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.resetScrollPositions(url);\n\t};\n\n\t/**\n\t * Stores the scroll positions for the current URL\n\t */\n\tcacheScrollPositions(url: string): void {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\n\t\t// retrieve the current scroll position for all containers\n\t\tconst containers = queryAll(this.options.scrollContainers).map((el) => ({\n\t\t\ttop: el.scrollTop,\n\t\t\tleft: el.scrollLeft\n\t\t}));\n\n\t\t// construct the final object entry, with the window scroll positions added\n\t\tconst positions = {\n\t\t\twindow: { top: window.scrollY, left: window.scrollX },\n\t\t\tcontainers\n\t\t};\n\n\t\tthis.cachedScrollPositions[cacheKey] = positions;\n\t}\n\n\t/**\n\t * Resets stored scroll positions for a given URL\n\t */\n\tresetScrollPositions(url: string): void {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\t\tdelete this.cachedScrollPositions[cacheKey];\n\t}\n\n\t/**\n\t * Get the stored scroll positions for a given URL from the cache\n\t */\n\tgetCachedScrollPositions(url: string): ScrollPositionsCacheEntry | undefined {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\t\treturn this.cachedScrollPositions[cacheKey];\n\t}\n\n\t/**\n\t * Restore the scroll positions for all matching scrollContainers\n\t */\n\trestoreScrollContainers(url: string): void {\n\t\t// get the stored scroll positions from the cache\n\t\tconst scrollPositions = this.getCachedScrollPositions(url);\n\t\tif (!scrollPositions || scrollPositions.containers.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// cycle through all containers on the current page and restore their scroll positions, if appropriate\n\t\tqueryAll(this.options.scrollContainers).forEach((el, index) => {\n\t\t\tconst scrollPosition = scrollPositions.containers[index];\n\t\t\tif (scrollPosition == null) return;\n\t\t\tel.scrollTop = scrollPosition.top;\n\t\t\tel.scrollLeft = scrollPosition.left;\n\t\t});\n\t}\n\n\tupdateScrollTarget(): void {\n\t\tconst { hash } = window.location;\n\t\tconst currentTarget = document.querySelector('[data-swup-scroll-target]');\n\t\tlet newTarget = this.getAnchorElement(hash);\n\t\tif (newTarget instanceof HTMLBodyElement) {\n\t\t\t// Special case: '#top' fragment returns <body> element\n\t\t\tnewTarget = null;\n\t\t}\n\t\tif (currentTarget === newTarget) {\n\t\t\treturn;\n\t\t}\n\t\tcurrentTarget?.removeAttribute('data-swup-scroll-target');\n\t\tnewTarget?.setAttribute('data-swup-scroll-target', '');\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Scrl", "constructor", "options", "this", "_raf", "_positionY", "_velocityY", "_targetPositionY", "_targetPositionYWithOffset", "_direction", "scrollTo", "offset", "nodeType", "Math", "round", "getBoundingClientRect", "top", "window", "pageYOffset", "parseInt", "console", "error", "document", "documentElement", "scrollHeight", "innerHeight", "body", "scrollTop", "onStart", "_animate", "onAlreadyAtPositions", "_update", "_render", "requestAnimationFrame", "onTick", "onEnd", "distance", "acceleration", "friction", "abs", "_extends", "onCancel", "addEventListener", "event", "cancelAnimationFrame", "passive", "SwupScrollPlugin", "Plugin", "constructor", "options", "super", "this", "name", "requires", "swup", "scrl", "defaults", "doScrollingRightAway", "animateScroll", "betweenPages", "samePageWithHash", "samePage", "scrollFriction", "scrollAcceleration", "getAnchorElement", "offset", "scrollContainers", "shouldResetScrollPosition", "markScrollTarget", "cachedScrollPositions", "previousScrollRestoration", "currentCacheKey", "hash", "getOffset", "el", "parseInt", "String", "onBeforeLinkToSelf", "visit", "scroll", "animate", "shouldAnimate", "handleScrollToTop", "_this$swup$scrollTo", "_this$swup", "scrollTo", "call", "onBeforeLinkToAnchor", "handleScrollToAnchor", "maybeScrollToAnchor", "onBeforeVisitStart", "scrolledToContent", "onVisitStart", "_visit$scroll$target", "cacheScrollPositions", "from", "url", "maybeResetScrollPositions", "scrollTarget", "target", "to", "doScrollingBetweenPages", "handleScrollToContent", "restoreScrollContainers", "_visit$scroll$target2", "_scrollPositions$wind", "history", "popstate", "animation", "reset", "scrollPositions", "getCachedScrollPositions", "top", "window", "requestAnimationFrame", "_this$swup$scrollTo2", "_this$swup2", "trigger", "resetScrollPositions", "_extends", "mount", "hooks", "create", "createVisit", "currentPageUrl", "Scrl", "onStart", "callSync", "undefined", "onEnd", "onCancel", "friction", "acceleration", "scrollRestoration", "animateHistoryBrowsing", "updateScrollTarget", "bind", "addEventListener", "on", "before", "priority", "replace", "unmount", "removeEventListener", "context", "_this$swup$scrollTo3", "_this$swup3", "element", "console", "warn", "Element", "elementTop", "getBoundingClientRect", "scrollY", "cacheKey", "resolveUrl", "containers", "queryAll", "map", "scrollTop", "left", "scrollLeft", "positions", "scrollX", "length", "forEach", "index", "scrollPosition", "_newTarget", "location", "currentTarget", "document", "querySelector", "newTarget", "HTMLBodyElement", "removeAttribute", "setAttribute"]
}
