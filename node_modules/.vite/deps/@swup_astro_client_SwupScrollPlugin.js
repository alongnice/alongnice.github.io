import {
  m
} from "./chunk-4G7MLUAF.js";
import {
  e
} from "./chunk-RU6KZPHD.js";
import "./chunk-EQCVQC35.js";

// node_modules/.pnpm/scrl@2.0.0/node_modules/scrl/dist/index.modern.js
function t() {
  return t = Object.assign ? Object.assign.bind() : function(t2) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var o = arguments[i2];
      for (var s in o) Object.prototype.hasOwnProperty.call(o, s) && (t2[s] = o[s]);
    }
    return t2;
  }, t.apply(this, arguments);
}
var i = class {
  constructor(i2) {
    this._raf = null, this._positionY = 0, this._velocityY = 0, this._targetPositionY = 0, this._targetPositionYWithOffset = 0, this._direction = 0, this.scrollTo = (t2) => {
      if (t2 && t2.nodeType) this._targetPositionY = Math.round(t2.getBoundingClientRect().top + window.pageYOffset);
      else {
        if (parseInt(this._targetPositionY) !== this._targetPositionY) return void console.error("Argument must be a number or an element.");
        this._targetPositionY = Math.round(t2);
      }
      this._targetPositionY > document.documentElement.scrollHeight - window.innerHeight && (this._targetPositionY = document.documentElement.scrollHeight - window.innerHeight), this._positionY = document.body.scrollTop || document.documentElement.scrollTop, this._direction = this._positionY > this._targetPositionY ? -1 : 1, this._targetPositionYWithOffset = this._targetPositionY + this._direction, this._velocityY = 0, this._positionY !== this._targetPositionY ? (this.options.onStart(), this._animate()) : this.options.onAlreadyAtPositions();
    }, this._animate = () => {
      this._update(), this._render(), 1 === this._direction && this._targetPositionY > this._positionY || -1 === this._direction && this._targetPositionY < this._positionY ? (this._raf = requestAnimationFrame(this._animate), this.options.onTick()) : (this._positionY = this._targetPositionY, this._render(), this._raf = null, this.options.onTick(), this.options.onEnd());
    }, this._update = () => {
      const t2 = this._targetPositionYWithOffset - this._positionY;
      return this._velocityY += t2 * this.options.acceleration, this._velocityY *= this.options.friction, this._positionY += this._velocityY, Math.abs(t2);
    }, this._render = () => {
      window.scrollTo(0, this._positionY);
    }, this.options = t({}, { onAlreadyAtPositions: () => {
    }, onCancel: () => {
    }, onEnd: () => {
    }, onStart: () => {
    }, onTick: () => {
    }, friction: 0.7, acceleration: 0.04 }, i2), i2 && i2.friction && (this.options.friction = 1 - i2.friction), window.addEventListener("mousewheel", (t2) => {
      this._raf && (this.options.onCancel(), cancelAnimationFrame(this._raf), this._raf = null);
    }, { passive: true });
  }
};

// node_modules/.pnpm/@swup+scroll-plugin@3.3.2_swup@4.7.0/node_modules/@swup/scroll-plugin/dist/index.modern.js
function e2() {
  return e2 = Object.assign ? Object.assign.bind() : function(t2) {
    for (var o = 1; o < arguments.length; o++) {
      var s = arguments[o];
      for (var e3 in s) Object.prototype.hasOwnProperty.call(s, e3) && (t2[e3] = s[e3]);
    }
    return t2;
  }, e2.apply(this, arguments);
}
var l = class extends e {
  constructor(t2 = {}) {
    super(), this.name = "SwupScrollPlugin", this.requires = { swup: ">=4.2.0" }, this.scrl = void 0, this.defaults = { doScrollingRightAway: false, animateScroll: { betweenPages: true, samePageWithHash: true, samePage: true }, scrollFriction: 0.3, scrollAcceleration: 0.04, getAnchorElement: void 0, offset: 0, scrollContainers: "[data-swup-scroll-container]", shouldResetScrollPosition: () => true, markScrollTarget: false }, this.options = void 0, this.cachedScrollPositions = {}, this.previousScrollRestoration = void 0, this.currentCacheKey = void 0, this.getAnchorElement = (t3 = "") => "function" == typeof this.options.getAnchorElement ? this.options.getAnchorElement(t3) : this.swup.getAnchorElement(t3), this.getOffset = (t3) => t3 ? "function" == typeof this.options.offset ? parseInt(String(this.options.offset(t3)), 10) : parseInt(String(this.options.offset), 10) : 0, this.onBeforeLinkToSelf = (t3) => {
      t3.scroll.animate = this.shouldAnimate("samePage");
    }, this.handleScrollToTop = (t3) => {
      var o, s;
      return null == (o = (s = this.swup).scrollTo) || o.call(s, 0, t3.scroll.animate), true;
    }, this.onBeforeLinkToAnchor = (t3) => {
      t3.scroll.animate = this.shouldAnimate("samePageWithHash");
    }, this.handleScrollToAnchor = (t3, { hash: o }) => this.maybeScrollToAnchor(o, t3.scroll.animate), this.onBeforeVisitStart = (t3) => {
      t3.scroll.scrolledToContent = false, t3.scroll.animate = this.shouldAnimate("betweenPages");
    }, this.onVisitStart = (t3) => {
      var o;
      this.cacheScrollPositions(t3.from.url), this.maybeResetScrollPositions(t3);
      const s = null != (o = t3.scroll.target) ? o : t3.to.hash;
      t3.scroll.animate && this.options.doScrollingRightAway && !s && this.doScrollingBetweenPages(t3);
    }, this.handleScrollToContent = (t3) => {
      t3.scroll.scrolledToContent || this.doScrollingBetweenPages(t3), this.restoreScrollContainers(t3.to.url);
    }, this.doScrollingBetweenPages = (t3) => {
      var o, s;
      if (t3.history.popstate && !t3.animation.animate) return;
      const e3 = null != (o = t3.scroll.target) ? o : t3.to.hash;
      if (e3 && this.maybeScrollToAnchor(e3, t3.scroll.animate)) return;
      if (!t3.scroll.reset) return;
      const l2 = this.getCachedScrollPositions(t3.to.url), r = (null == l2 || null == (s = l2.window) ? void 0 : s.top) || 0;
      requestAnimationFrame(() => {
        var o2, s2;
        return null == (o2 = (s2 = this.swup).scrollTo) ? void 0 : o2.call(s2, r, t3.scroll.animate);
      }), t3.scroll.scrolledToContent = true;
    }, this.maybeResetScrollPositions = (t3) => {
      const { popstate: o } = t3.history, { url: s } = t3.to, { el: e3 } = t3.trigger;
      o || e3 && !this.options.shouldResetScrollPosition(e3) || this.resetScrollPositions(s);
    }, this.options = e2({}, this.defaults, t2);
  }
  mount() {
    const t2 = this.swup;
    t2.hooks.create("scroll:start"), t2.hooks.create("scroll:end");
    const o = this.swup.createVisit({ to: this.swup.currentPageUrl });
    this.scrl = new i({ onStart: () => t2.hooks.callSync("scroll:start", o, void 0), onEnd: () => t2.hooks.callSync("scroll:end", o, void 0), onCancel: () => t2.hooks.callSync("scroll:end", o, void 0), friction: this.options.scrollFriction, acceleration: this.options.scrollAcceleration }), t2.scrollTo = (s, e3 = true) => {
      e3 ? this.scrl.scrollTo(s) : (t2.hooks.callSync("scroll:start", o, void 0), window.scrollTo(0, s), t2.hooks.callSync("scroll:end", o, void 0));
    }, this.previousScrollRestoration = window.history.scrollRestoration, t2.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.updateScrollTarget = this.updateScrollTarget.bind(this), this.options.markScrollTarget && (window.addEventListener("popstate", this.updateScrollTarget), window.addEventListener("hashchange", this.updateScrollTarget), this.on("page:view", this.updateScrollTarget), this.on("link:anchor", this.updateScrollTarget), this.on("link:self", this.updateScrollTarget), this.updateScrollTarget()), this.before("visit:start", this.onBeforeVisitStart, { priority: -1 }), this.on("visit:start", this.onVisitStart, { priority: 1 }), this.replace("content:scroll", this.handleScrollToContent), this.before("link:self", this.onBeforeLinkToSelf, { priority: -1 }), this.replace("scroll:top", this.handleScrollToTop), this.before("link:anchor", this.onBeforeLinkToAnchor, { priority: -1 }), this.replace("scroll:anchor", this.handleScrollToAnchor);
  }
  unmount() {
    super.unmount(), this.previousScrollRestoration && (window.history.scrollRestoration = this.previousScrollRestoration), window.removeEventListener("popstate", this.updateScrollTarget), window.removeEventListener("hashchange", this.updateScrollTarget), this.cachedScrollPositions = {}, delete this.swup.scrollTo, delete this.scrl;
  }
  shouldAnimate(t2) {
    return "boolean" == typeof this.options.animateScroll ? this.options.animateScroll : this.options.animateScroll[t2];
  }
  maybeScrollToAnchor(t2, o = false) {
    var s, e3;
    if (!t2) return false;
    const l2 = this.getAnchorElement(t2);
    if (!l2) return console.warn(`Anchor target ${t2} not found`), false;
    if (!(l2 instanceof Element)) return console.warn(`Anchor target ${t2} is not a DOM node`), false;
    const { top: r } = l2.getBoundingClientRect(), i2 = r + window.scrollY - this.getOffset(l2);
    return null == (s = (e3 = this.swup).scrollTo) || s.call(e3, i2, o), true;
  }
  cacheScrollPositions(t2) {
    const s = this.swup.resolveUrl(t2), e3 = m(this.options.scrollContainers).map((t3) => ({ top: t3.scrollTop, left: t3.scrollLeft })), l2 = { window: { top: window.scrollY, left: window.scrollX }, containers: e3 };
    this.cachedScrollPositions[s] = l2;
  }
  resetScrollPositions(t2) {
    const o = this.swup.resolveUrl(t2);
    delete this.cachedScrollPositions[o];
  }
  getCachedScrollPositions(t2) {
    const o = this.swup.resolveUrl(t2);
    return this.cachedScrollPositions[o];
  }
  restoreScrollContainers(t2) {
    const s = this.getCachedScrollPositions(t2);
    s && 0 !== s.containers.length && m(this.options.scrollContainers).forEach((t3, o) => {
      const e3 = s.containers[o];
      null != e3 && (t3.scrollTop = e3.top, t3.scrollLeft = e3.left);
    });
  }
  updateScrollTarget() {
    var t2;
    const { hash: o } = window.location, s = document.querySelector("[data-swup-scroll-target]");
    let e3 = this.getAnchorElement(o);
    e3 instanceof HTMLBodyElement && (e3 = null), s !== e3 && (null == s || s.removeAttribute("data-swup-scroll-target"), null == (t2 = e3) || t2.setAttribute("data-swup-scroll-target", ""));
  }
};
export {
  l as default
};
//# sourceMappingURL=@swup_astro_client_SwupScrollPlugin.js.map
