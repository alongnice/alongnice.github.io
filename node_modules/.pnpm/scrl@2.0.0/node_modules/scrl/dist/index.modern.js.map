{"version":3,"file":"index.modern.js","sources":["../src/index.js"],"sourcesContent":["export default class Scrl {\n    _raf = null;\n    _positionY = 0;\n    _velocityY = 0;\n    _targetPositionY = 0;\n    _targetPositionYWithOffset = 0;\n    _direction = 0;\n\n    constructor(options) {\n        // default options\n        const defaults = {\n            onAlreadyAtPositions: () => {},\n            onCancel: () => {},\n            onEnd: () => {},\n            onStart: () => {},\n            onTick: () => {},\n            friction: .7, // 1 - .3\n            acceleration: .04,\n        }\n\n        // merge options\n        this.options = {\n            ...defaults,\n            ...options,\n        };\n\n        // set reverse friction\n        if (options && options.friction) {\n            this.options.friction = 1 - options.friction;\n        }\n\n        // register listener for cancel on wheel event\n        window.addEventListener('mousewheel', event => {\n            if (this._raf) {\n                this.options.onCancel();\n                cancelAnimationFrame(this._raf);\n                this._raf = null;\n            }\n        }, {\n            passive: true\n        });\n    }\n\n    scrollTo = (offset) => {\n        if (offset && offset.nodeType) {\n            // the offset is element\n            this._targetPositionY = Math.round(offset.getBoundingClientRect().top + window.pageYOffset);\n        } else if (parseInt(this._targetPositionY) === this._targetPositionY) {\n            // the offset is a number\n            this._targetPositionY = Math.round(offset);\n        } else {\n            console.error('Argument must be a number or an element.');\n            return;\n        }\n\n        // don't animate beyond the document height\n        if (this._targetPositionY > document.documentElement.scrollHeight - window.innerHeight) {\n            this._targetPositionY = document.documentElement.scrollHeight - window.innerHeight;\n        }\n\n        // calculated required values\n        this._positionY = document.body.scrollTop || document.documentElement.scrollTop;\n        this._direction = (this._positionY > this._targetPositionY) ? -1 : 1;\n        this._targetPositionYWithOffset = this._targetPositionY + this._direction;\n        this._velocityY = 0;\n\n        if (this._positionY !== this._targetPositionY) {\n            // start animation\n            this.options.onStart();\n            this._animate();\n        } else {\n            // page is already at the position\n            this.options.onAlreadyAtPositions();\n        }\n    };\n\n    _animate = () => {\n        const distance = this._update();\n        this._render();\n\n        if (this._direction === 1 && this._targetPositionY > this._positionY || this._direction === -1 && this._targetPositionY < this._positionY) {\n            // calculate next position\n            this._raf = requestAnimationFrame(this._animate);\n            this.options.onTick();\n        } else {\n            // finish and set position to the final position\n            this._positionY = this._targetPositionY;\n            this._render();\n            this._raf = null;\n            this.options.onTick();\n            this.options.onEnd();\n            // this.triggerEvent('scrollDone')\n        }\n    };\n\n    _update = () => {\n        const distance = this._targetPositionYWithOffset - this._positionY;\n        const attraction = distance * this.options.acceleration;\n\n        this._velocityY += attraction;\n\n        this._velocityY *= this.options.friction;\n        this._positionY += this._velocityY;\n\n        return Math.abs(distance);\n    };\n\n    _render = () => {\n        window.scrollTo(0, this._positionY);\n    };\n}\n"],"names":["Scrl","constructor","options","this","_raf","_positionY","_velocityY","_targetPositionY","_targetPositionYWithOffset","_direction","scrollTo","offset","nodeType","Math","round","getBoundingClientRect","top","window","pageYOffset","parseInt","console","error","document","documentElement","scrollHeight","innerHeight","body","scrollTop","onStart","_animate","onAlreadyAtPositions","_update","_render","requestAnimationFrame","onTick","onEnd","distance","acceleration","friction","abs","_extends","onCancel","addEventListener","event","cancelAnimationFrame","passive"],"mappings":"oOAAqBA,MAAAA,EAQjBC,YAAYC,GAASC,KAPrBC,KAAO,KAAID,KACXE,WAAa,EAACF,KACdG,WAAa,EAACH,KACdI,iBAAmB,EAACJ,KACpBK,2BAA6B,EAACL,KAC9BM,WAAa,EAACN,KAqCdO,SAAYC,IACR,GAAIA,GAAUA,EAAOC,SAEjBT,KAAKI,iBAAmBM,KAAKC,MAAMH,EAAOI,wBAAwBC,IAAMC,OAAOC,iBACxEC,IAAAA,SAAShB,KAAKI,oBAAsBJ,KAAKI,iBAKhD,YADAa,QAAQC,MAAM,4CAFdlB,KAAKI,iBAAmBM,KAAKC,MAAMH,EAIvC,CAGIR,KAAKI,iBAAmBe,SAASC,gBAAgBC,aAAeP,OAAOQ,cACvEtB,KAAKI,iBAAmBe,SAASC,gBAAgBC,aAAeP,OAAOQ,aAI3EtB,KAAKE,WAAaiB,SAASI,KAAKC,WAAaL,SAASC,gBAAgBI,UACtExB,KAAKM,WAAcN,KAAKE,WAAaF,KAAKI,kBAAqB,EAAI,EACnEJ,KAAKK,2BAA6BL,KAAKI,iBAAmBJ,KAAKM,WAC/DN,KAAKG,WAAa,EAEdH,KAAKE,aAAeF,KAAKI,kBAEzBJ,KAAKD,QAAQ0B,UACbzB,KAAK0B,YAGL1B,KAAKD,QAAQ4B,sBACjB,EAGJD,KAAAA,SAAW,KACU1B,KAAK4B,UACtB5B,KAAK6B,UAEmB,IAApB7B,KAAKM,YAAoBN,KAAKI,iBAAmBJ,KAAKE,aAAmC,IAArBF,KAAKM,YAAqBN,KAAKI,iBAAmBJ,KAAKE,YAE3HF,KAAKC,KAAO6B,sBAAsB9B,KAAK0B,UACvC1B,KAAKD,QAAQgC,WAGb/B,KAAKE,WAAaF,KAAKI,iBACvBJ,KAAK6B,UACL7B,KAAKC,KAAO,KACZD,KAAKD,QAAQgC,SACb/B,KAAKD,QAAQiC,QAEjB,EACHhC,KAED4B,QAAU,KACN,MAAMK,EAAWjC,KAAKK,2BAA6BL,KAAKE,WAQxD,OALAF,KAAKG,YAFc8B,EAAWjC,KAAKD,QAAQmC,aAI3ClC,KAAKG,YAAcH,KAAKD,QAAQoC,SAChCnC,KAAKE,YAAcF,KAAKG,WAEjBO,KAAK0B,IAAIH,EAAQ,EAG5BJ,KAAAA,QAAU,KACNf,OAAOP,SAAS,EAAGP,KAAKE,WAAU,EAvFlCF,KAAKD,QAAOsC,EAAA,CAAA,EAXK,CACbV,qBAAsB,OACtBW,SAAU,OACVN,MAAO,OACPP,QAAS,OACTM,OAAQ,OACRI,SAAU,GACVD,aAAc,KAMXnC,GAIHA,GAAWA,EAAQoC,WACnBnC,KAAKD,QAAQoC,SAAW,EAAIpC,EAAQoC,UAIxCrB,OAAOyB,iBAAiB,aAAcC,IAC9BxC,KAAKC,OACLD,KAAKD,QAAQuC,WACbG,qBAAqBzC,KAAKC,MAC1BD,KAAKC,KAAO,KAChB,EACD,CACCyC,SAAS,GAEjB"}