var t=require("@swup/plugin"),o=require("swup"),s=require("scrl");function e(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var l=/*#__PURE__*/e(t),i=/*#__PURE__*/e(s);module.exports=class extends l.default{constructor(t={}){super(),this.name="SwupScrollPlugin",this.requires={swup:">=4.2.0"},this.scrl=void 0,this.defaults={doScrollingRightAway:!1,animateScroll:{betweenPages:!0,samePageWithHash:!0,samePage:!0},scrollFriction:.3,scrollAcceleration:.04,getAnchorElement:void 0,offset:0,scrollContainers:"[data-swup-scroll-container]",shouldResetScrollPosition:()=>!0,markScrollTarget:!1},this.options=void 0,this.cachedScrollPositions={},this.previousScrollRestoration=void 0,this.currentCacheKey=void 0,this.getAnchorElement=(t="")=>"function"==typeof this.options.getAnchorElement?this.options.getAnchorElement(t):this.swup.getAnchorElement(t),this.getOffset=t=>t?"function"==typeof this.options.offset?parseInt(String(this.options.offset(t)),10):parseInt(String(this.options.offset),10):0,this.onBeforeLinkToSelf=t=>{t.scroll.animate=this.shouldAnimate("samePage")},this.handleScrollToTop=t=>(this.swup.scrollTo?.(0,t.scroll.animate),!0),this.onBeforeLinkToAnchor=t=>{t.scroll.animate=this.shouldAnimate("samePageWithHash")},this.handleScrollToAnchor=(t,{hash:o})=>this.maybeScrollToAnchor(o,t.scroll.animate),this.onBeforeVisitStart=t=>{t.scroll.scrolledToContent=!1,t.scroll.animate=this.shouldAnimate("betweenPages")},this.onVisitStart=t=>{this.cacheScrollPositions(t.from.url),this.maybeResetScrollPositions(t),t.scroll.animate&&this.options.doScrollingRightAway&&!(t.scroll.target??t.to.hash)&&this.doScrollingBetweenPages(t)},this.handleScrollToContent=t=>{t.scroll.scrolledToContent||this.doScrollingBetweenPages(t),this.restoreScrollContainers(t.to.url)},this.doScrollingBetweenPages=t=>{if(t.history.popstate&&!t.animation.animate)return;const o=t.scroll.target??t.to.hash;if(o&&this.maybeScrollToAnchor(o,t.scroll.animate))return;if(!t.scroll.reset)return;const s=this.getCachedScrollPositions(t.to.url),e=s?.window?.top||0;requestAnimationFrame(()=>this.swup.scrollTo?.(e,t.scroll.animate)),t.scroll.scrolledToContent=!0},this.maybeResetScrollPositions=t=>{const{popstate:o}=t.history,{url:s}=t.to,{el:e}=t.trigger;o||e&&!this.options.shouldResetScrollPosition(e)||this.resetScrollPositions(s)},this.options={...this.defaults,...t}}mount(){const t=this.swup;t.hooks.create("scroll:start"),t.hooks.create("scroll:end");const o=this.swup.createVisit({to:this.swup.currentPageUrl});this.scrl=new i.default({onStart:()=>t.hooks.callSync("scroll:start",o,void 0),onEnd:()=>t.hooks.callSync("scroll:end",o,void 0),onCancel:()=>t.hooks.callSync("scroll:end",o,void 0),friction:this.options.scrollFriction,acceleration:this.options.scrollAcceleration}),t.scrollTo=(s,e=!0)=>{e?this.scrl.scrollTo(s):(t.hooks.callSync("scroll:start",o,void 0),window.scrollTo(0,s),t.hooks.callSync("scroll:end",o,void 0))},this.previousScrollRestoration=window.history.scrollRestoration,t.options.animateHistoryBrowsing&&(window.history.scrollRestoration="manual"),this.updateScrollTarget=this.updateScrollTarget.bind(this),this.options.markScrollTarget&&(window.addEventListener("popstate",this.updateScrollTarget),window.addEventListener("hashchange",this.updateScrollTarget),this.on("page:view",this.updateScrollTarget),this.on("link:anchor",this.updateScrollTarget),this.on("link:self",this.updateScrollTarget),this.updateScrollTarget()),this.before("visit:start",this.onBeforeVisitStart,{priority:-1}),this.on("visit:start",this.onVisitStart,{priority:1}),this.replace("content:scroll",this.handleScrollToContent),this.before("link:self",this.onBeforeLinkToSelf,{priority:-1}),this.replace("scroll:top",this.handleScrollToTop),this.before("link:anchor",this.onBeforeLinkToAnchor,{priority:-1}),this.replace("scroll:anchor",this.handleScrollToAnchor)}unmount(){super.unmount(),this.previousScrollRestoration&&(window.history.scrollRestoration=this.previousScrollRestoration),window.removeEventListener("popstate",this.updateScrollTarget),window.removeEventListener("hashchange",this.updateScrollTarget),this.cachedScrollPositions={},delete this.swup.scrollTo,delete this.scrl}shouldAnimate(t){return"boolean"==typeof this.options.animateScroll?this.options.animateScroll:this.options.animateScroll[t]}maybeScrollToAnchor(t,o=!1){if(!t)return!1;const s=this.getAnchorElement(t);if(!s)return console.warn(`Anchor target ${t} not found`),!1;if(!(s instanceof Element))return console.warn(`Anchor target ${t} is not a DOM node`),!1;const{top:e}=s.getBoundingClientRect(),l=e+window.scrollY-this.getOffset(s);return this.swup.scrollTo?.(l,o),!0}cacheScrollPositions(t){const s=this.swup.resolveUrl(t),e=o.queryAll(this.options.scrollContainers).map(t=>({top:t.scrollTop,left:t.scrollLeft})),l={window:{top:window.scrollY,left:window.scrollX},containers:e};this.cachedScrollPositions[s]=l}resetScrollPositions(t){const o=this.swup.resolveUrl(t);delete this.cachedScrollPositions[o]}getCachedScrollPositions(t){const o=this.swup.resolveUrl(t);return this.cachedScrollPositions[o]}restoreScrollContainers(t){const s=this.getCachedScrollPositions(t);s&&0!==s.containers.length&&o.queryAll(this.options.scrollContainers).forEach((t,o)=>{const e=s.containers[o];null!=e&&(t.scrollTop=e.top,t.scrollLeft=e.left)})}updateScrollTarget(){const{hash:t}=window.location,o=document.querySelector("[data-swup-scroll-target]");let s=this.getAnchorElement(t);s instanceof HTMLBodyElement&&(s=null),o!==s&&(o?.removeAttribute("data-swup-scroll-target"),s?.setAttribute("data-swup-scroll-target",""))}};
//# sourceMappingURL=index.cjs.map
