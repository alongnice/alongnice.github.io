{"version":3,"file":"index.umd.js","sources":["../node_modules/@swup/plugin/dist/index.modern.js","../node_modules/scrl/dist/index.modern.js","../src/index.ts"],"sourcesContent":["function r(){return r=Object.assign?Object.assign.bind():function(r){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=e[t])}return r},r.apply(this,arguments)}const n=r=>String(r).split(\".\").map(r=>String(parseInt(r||\"0\",10))).concat([\"0\",\"0\"]).slice(0,3).join(\".\");class e{constructor(){this.isSwupPlugin=!0,this.swup=void 0,this.version=void 0,this.requires={},this.handlersToUnregister=[]}mount(){}unmount(){this.handlersToUnregister.forEach(r=>r()),this.handlersToUnregister=[]}_beforeMount(){if(!this.name)throw new Error(\"You must define a name of plugin when creating a class.\")}_afterUnmount(){}_checkRequirements(){return\"object\"!=typeof this.requires||Object.entries(this.requires).forEach(([r,e])=>{if(!function(r,e,t){const s=function(r,n){var e;if(\"swup\"===r)return null!=(e=n.version)?e:\"\";{var t;const e=n.findPlugin(r);return null!=(t=null==e?void 0:e.version)?t:\"\"}}(r,t);return!!s&&((r,e)=>e.every(e=>{const[,t,s]=e.match(/^([\\D]+)?(.*)$/)||[];var o,i;return((r,n)=>{const e={\"\":r=>0===r,\">\":r=>r>0,\">=\":r=>r>=0,\"<\":r=>r<0,\"<=\":r=>r<=0};return(e[n]||e[\"\"])(r)})((i=s,o=n(o=r),i=n(i),o.localeCompare(i,void 0,{numeric:!0})),t||\">=\")}))(s,e)}(r,e=Array.isArray(e)?e:[e],this.swup)){const n=`${r} ${e.join(\", \")}`;throw new Error(`Plugin version mismatch: ${this.name} requires ${n}`)}}),!0}on(r,n,e={}){var t;n=!(t=n).name.startsWith(\"bound \")||t.hasOwnProperty(\"prototype\")?n.bind(this):n;const s=this.swup.hooks.on(r,n,e);return this.handlersToUnregister.push(s),s}once(n,e,t={}){return this.on(n,e,r({},t,{once:!0}))}before(n,e,t={}){return this.on(n,e,r({},t,{before:!0}))}replace(n,e,t={}){return this.on(n,e,r({},t,{replace:!0}))}off(r,n){return this.swup.hooks.off(r,n)}}export{e as default};\n//# sourceMappingURL=index.modern.js.map\n","function t(){return t=Object.assign?Object.assign.bind():function(t){for(var i=1;i<arguments.length;i++){var o=arguments[i];for(var s in o)Object.prototype.hasOwnProperty.call(o,s)&&(t[s]=o[s])}return t},t.apply(this,arguments)}class i{constructor(i){this._raf=null,this._positionY=0,this._velocityY=0,this._targetPositionY=0,this._targetPositionYWithOffset=0,this._direction=0,this.scrollTo=t=>{if(t&&t.nodeType)this._targetPositionY=Math.round(t.getBoundingClientRect().top+window.pageYOffset);else{if(parseInt(this._targetPositionY)!==this._targetPositionY)return void console.error(\"Argument must be a number or an element.\");this._targetPositionY=Math.round(t)}this._targetPositionY>document.documentElement.scrollHeight-window.innerHeight&&(this._targetPositionY=document.documentElement.scrollHeight-window.innerHeight),this._positionY=document.body.scrollTop||document.documentElement.scrollTop,this._direction=this._positionY>this._targetPositionY?-1:1,this._targetPositionYWithOffset=this._targetPositionY+this._direction,this._velocityY=0,this._positionY!==this._targetPositionY?(this.options.onStart(),this._animate()):this.options.onAlreadyAtPositions()},this._animate=()=>{this._update(),this._render(),1===this._direction&&this._targetPositionY>this._positionY||-1===this._direction&&this._targetPositionY<this._positionY?(this._raf=requestAnimationFrame(this._animate),this.options.onTick()):(this._positionY=this._targetPositionY,this._render(),this._raf=null,this.options.onTick(),this.options.onEnd())},this._update=()=>{const t=this._targetPositionYWithOffset-this._positionY;return this._velocityY+=t*this.options.acceleration,this._velocityY*=this.options.friction,this._positionY+=this._velocityY,Math.abs(t)},this._render=()=>{window.scrollTo(0,this._positionY)},this.options=t({},{onAlreadyAtPositions:()=>{},onCancel:()=>{},onEnd:()=>{},onStart:()=>{},onTick:()=>{},friction:.7,acceleration:.04},i),i&&i.friction&&(this.options.friction=1-i.friction),window.addEventListener(\"mousewheel\",t=>{this._raf&&(this.options.onCancel(),cancelAnimationFrame(this._raf),this._raf=null)},{passive:!0})}}export{i as default};\n//# sourceMappingURL=index.modern.js.map\n","import Plugin from '@swup/plugin';\nimport { Handler, Visit, queryAll } from 'swup';\n// @ts-expect-error\nimport Scrl from 'scrl';\n\nexport type Options = {\n\tdoScrollingRightAway: boolean;\n\tanimateScroll: {\n\t\tbetweenPages: boolean;\n\t\tsamePageWithHash: boolean;\n\t\tsamePage: boolean;\n\t};\n\tscrollFriction: number;\n\tscrollAcceleration: number;\n\tgetAnchorElement?: (hash: string) => Element | null;\n\toffset: number | ((el: Element) => number);\n\tscrollContainers: `[data-swup-scroll-container]`;\n\tshouldResetScrollPosition: (trigger: Element) => boolean;\n\tmarkScrollTarget?: boolean;\n};\n\ntype ScrollPosition = {\n\ttop: number;\n\tleft: number;\n};\n\ntype ScrollPositionsCacheEntry = {\n\twindow: ScrollPosition;\n\tcontainers: ScrollPosition[];\n};\n\ntype ScrollPositionsCache = Record<string, ScrollPositionsCacheEntry>;\n\ndeclare module 'swup' {\n\texport interface Swup {\n\t\tscrollTo?: (offset: number, animate?: boolean) => void;\n\t}\n\n\texport interface VisitScroll {\n\t\t/** Whether scrolling is animated. Set by Scroll Plugin. */\n\t\tanimate?: boolean;\n\t\t/** Whether the scroll position was reset after page load. Set by Scroll Plugin. */\n\t\tscrolledToContent?: boolean;\n\t}\n\n\texport interface HookDefinitions {\n\t\t'scroll:start': undefined;\n\t\t'scroll:end': undefined;\n\t}\n}\n\n/**\n * Scroll Plugin\n */\nexport default class SwupScrollPlugin extends Plugin {\n\tname = 'SwupScrollPlugin';\n\n\trequires = { swup: '>=4.2.0' };\n\n\tscrl: any;\n\n\tdefaults: Options = {\n\t\tdoScrollingRightAway: false,\n\t\tanimateScroll: {\n\t\t\tbetweenPages: true,\n\t\t\tsamePageWithHash: true,\n\t\t\tsamePage: true\n\t\t},\n\t\tscrollFriction: 0.3,\n\t\tscrollAcceleration: 0.04,\n\t\tgetAnchorElement: undefined,\n\t\toffset: 0,\n\t\tscrollContainers: `[data-swup-scroll-container]`,\n\t\tshouldResetScrollPosition: () => true,\n\t\tmarkScrollTarget: false\n\t};\n\n\toptions: Options;\n\n\tcachedScrollPositions: ScrollPositionsCache = {};\n\tpreviousScrollRestoration?: ScrollRestoration;\n\tcurrentCacheKey?: string;\n\n\tconstructor(options: Partial<Options> = {}) {\n\t\tsuper();\n\t\tthis.options = { ...this.defaults, ...options };\n\t}\n\n\tmount() {\n\t\tconst swup = this.swup;\n\n\t\tswup.hooks.create('scroll:start');\n\t\tswup.hooks.create('scroll:end');\n\n\t\t// @ts-expect-error: createVisit is currently private, need to make this semi-public somehow\n\t\tconst visit = this.swup.createVisit({ to: this.swup.currentPageUrl });\n\n\t\t// Initialize Scrl lib for smooth animations\n\t\tthis.scrl = new Scrl({\n\t\t\tonStart: () => swup.hooks.callSync('scroll:start', visit, undefined),\n\t\t\tonEnd: () => swup.hooks.callSync('scroll:end', visit, undefined),\n\t\t\tonCancel: () => swup.hooks.callSync('scroll:end', visit, undefined),\n\t\t\tfriction: this.options.scrollFriction,\n\t\t\tacceleration: this.options.scrollAcceleration\n\t\t});\n\n\t\t// Add scrollTo method to swup and animate based on current animateScroll option\n\t\tswup.scrollTo = (offset, animate = true) => {\n\t\t\tif (animate) {\n\t\t\t\tthis.scrl.scrollTo(offset);\n\t\t\t} else {\n\t\t\t\tswup.hooks.callSync('scroll:start', visit, undefined);\n\t\t\t\twindow.scrollTo(0, offset);\n\t\t\t\tswup.hooks.callSync('scroll:end', visit, undefined);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Disable browser scroll restoration for history visits\n\t\t * if `swup.options.animateHistoryBrowsing` is true\n\t\t * Store the previous setting to be able to properly restore it on unmount\n\t\t */\n\t\tthis.previousScrollRestoration = window.history.scrollRestoration;\n\t\tif (swup.options.animateHistoryBrowsing) {\n\t\t\twindow.history.scrollRestoration = 'manual';\n\t\t}\n\n\t\t/**\n\t\t * Mark the current scroll target element with a `data-swup-scroll-target` attribute\n\t\t */\n\t\tthis.updateScrollTarget = this.updateScrollTarget.bind(this);\n\t\tif (this.options.markScrollTarget) {\n\t\t\twindow.addEventListener('popstate', this.updateScrollTarget);\n\t\t\twindow.addEventListener('hashchange', this.updateScrollTarget);\n\t\t\tthis.on('page:view', this.updateScrollTarget);\n\t\t\tthis.on('link:anchor', this.updateScrollTarget);\n\t\t\tthis.on('link:self', this.updateScrollTarget);\n\t\t\tthis.updateScrollTarget();\n\t\t}\n\n\t\t// scroll to the top of the page when a visit starts, before replacing the content\n\t\tthis.before('visit:start', this.onBeforeVisitStart, { priority: -1 });\n\t\tthis.on('visit:start', this.onVisitStart, { priority: 1 });\n\n\t\t// scroll to the top or target element after replacing the content\n\t\tthis.replace('content:scroll', this.handleScrollToContent);\n\n\t\t// scroll to the top of the same page\n\t\tthis.before('link:self', this.onBeforeLinkToSelf, { priority: -1 });\n\t\tthis.replace('scroll:top', this.handleScrollToTop);\n\n\t\t// scroll to an anchor on the same page\n\t\tthis.before('link:anchor', this.onBeforeLinkToAnchor, { priority: -1 });\n\t\tthis.replace('scroll:anchor', this.handleScrollToAnchor);\n\t}\n\n\t/**\n\t * Runs when the plugin is unmounted\n\t */\n\tunmount() {\n\t\tsuper.unmount();\n\n\t\tif (this.previousScrollRestoration) {\n\t\t\twindow.history.scrollRestoration = this.previousScrollRestoration;\n\t\t}\n\n\t\twindow.removeEventListener('popstate', this.updateScrollTarget);\n\t\twindow.removeEventListener('hashchange', this.updateScrollTarget);\n\n\t\tthis.cachedScrollPositions = {};\n\t\tdelete this.swup.scrollTo;\n\t\tdelete this.scrl;\n\t}\n\n\t/**\n\t * Detects if a scroll should be animated, based on context\n\t */\n\tshouldAnimate(context: keyof Options['animateScroll']): boolean {\n\t\tif (typeof this.options.animateScroll === 'boolean') {\n\t\t\treturn this.options.animateScroll;\n\t\t}\n\t\treturn this.options.animateScroll[context];\n\t}\n\n\t/**\n\t * Get an element based on anchor\n\t */\n\tgetAnchorElement = (hash: string = ''): Element | null => {\n\t\t// Look for a custom function provided via the plugin options\n\t\tif (typeof this.options.getAnchorElement === 'function') {\n\t\t\treturn this.options.getAnchorElement(hash);\n\t\t}\n\n\t\treturn this.swup.getAnchorElement(hash);\n\t};\n\n\t/**\n\t * Get the offset for a scroll\n\t */\n\tgetOffset = (el?: Element): number => {\n\t\tif (!el) return 0;\n\t\t// If options.offset is a function, apply and return it\n\t\tif (typeof this.options.offset === 'function') {\n\t\t\treturn parseInt(String(this.options.offset(el)), 10);\n\t\t}\n\t\t// Otherwise, return the sanitized offset\n\t\treturn parseInt(String(this.options.offset), 10);\n\t};\n\n\t/**\n\t * Store scroll animation status in visit object before scrolling up\n\t */\n\tonBeforeLinkToSelf: Handler<'link:self'> = (visit) => {\n\t\tvisit.scroll.animate = this.shouldAnimate('samePage');\n\t};\n\n\t/**\n\t * Scroll to top on `scroll:top` hook\n\t */\n\thandleScrollToTop: Handler<'scroll:top'> = (visit) => {\n\t\tthis.swup.scrollTo?.(0, visit.scroll.animate);\n\t\treturn true;\n\t};\n\n\t/**\n\t * Store scroll animation status in visit object before scrolling to anchor\n\t */\n\tonBeforeLinkToAnchor: Handler<'link:anchor'> = (visit) => {\n\t\tvisit.scroll.animate = this.shouldAnimate('samePageWithHash');\n\t};\n\n\t/**\n\t * Scroll to anchor on `scroll:anchor` hook\n\t */\n\thandleScrollToAnchor: Handler<'scroll:anchor'> = (visit, { hash }) => {\n\t\treturn this.maybeScrollToAnchor(hash, visit.scroll.animate);\n\t};\n\n\t/**\n\t * Attempts to scroll to an anchor\n\t */\n\tmaybeScrollToAnchor(hash?: string, animate: boolean = false): boolean {\n\t\tif (!hash) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst element = this.getAnchorElement(hash);\n\t\tif (!element) {\n\t\t\tconsole.warn(`Anchor target ${hash} not found`);\n\t\t\treturn false;\n\t\t}\n\t\tif (!(element instanceof Element)) {\n\t\t\tconsole.warn(`Anchor target ${hash} is not a DOM node`);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { top: elementTop } = element.getBoundingClientRect();\n\t\tconst top = elementTop + window.scrollY - this.getOffset(element);\n\t\tthis.swup.scrollTo?.(top, animate);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Prepare scrolling before visit:start hook\n\t */\n\tonBeforeVisitStart: Handler<'visit:start'> = (visit) => {\n\t\tvisit.scroll.scrolledToContent = false;\n\t\tvisit.scroll.animate = this.shouldAnimate('betweenPages');\n\t};\n\n\t/**\n\t * Check whether to scroll in `visit:start` hook\n\t */\n\tonVisitStart: Handler<'visit:start'> = (visit) => {\n\t\tthis.cacheScrollPositions(visit.from.url);\n\t\tthis.maybeResetScrollPositions(visit);\n\n\t\tconst scrollTarget = visit.scroll.target ?? visit.to.hash;\n\n\t\t// Conditions for scrolling before content replace:\n\t\t// - scroll is animated (otherwise the effect is useless)\n\t\t// - no scroll target is defined (needs to wait until new content is there)\n\t\tif (visit.scroll.animate && this.options.doScrollingRightAway && !scrollTarget) {\n\t\t\tthis.doScrollingBetweenPages(visit);\n\t\t}\n\t};\n\n\t/**\n\t * Check whether to scroll in `content:scroll` hook\n\t */\n\thandleScrollToContent: Handler<'content:scroll'> = (visit) => {\n\t\tif (!visit.scroll.scrolledToContent) {\n\t\t\tthis.doScrollingBetweenPages(visit);\n\t\t}\n\t\tthis.restoreScrollContainers(visit.to.url);\n\t};\n\n\t/**\n\t * Scrolls the window\n\t */\n\tdoScrollingBetweenPages = (visit: Visit): void => {\n\t\t// Bail early on popstate if not animated: browser will handle it\n\t\tif (visit.history.popstate && !visit.animation.animate) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Try scrolling to a given anchor\n\t\tconst scrollTarget = visit.scroll.target ?? visit.to.hash;\n\t\tif (scrollTarget && this.maybeScrollToAnchor(scrollTarget, visit.scroll.animate)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Allow not resetting scroll position\n\t\tif (!visit.scroll.reset) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Finally, scroll to either the stored scroll position or to the very top of the page\n\t\tconst scrollPositions = this.getCachedScrollPositions(visit.to.url);\n\t\tconst top = scrollPositions?.window?.top || 0;\n\n\t\t// Give possible JavaScript time to execute before scrolling\n\t\trequestAnimationFrame(() => this.swup.scrollTo?.(top, visit.scroll.animate));\n\n\t\tvisit.scroll.scrolledToContent = true;\n\t};\n\n\t/**\n\t * Reset cached scroll positions. Do not reset if:\n\t * - the visit is a history visit\n\t * - the visit is triggered by a link and shouldResetScrollPosition(link) returns false\n\t */\n\tmaybeResetScrollPositions = (visit: Visit): void => {\n\t\tconst { popstate } = visit.history;\n\t\tconst { url } = visit.to;\n\t\tconst { el } = visit.trigger;\n\t\tif (popstate) {\n\t\t\treturn;\n\t\t}\n\t\tif (el && !this.options.shouldResetScrollPosition(el)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.resetScrollPositions(url);\n\t};\n\n\t/**\n\t * Stores the scroll positions for the current URL\n\t */\n\tcacheScrollPositions(url: string): void {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\n\t\t// retrieve the current scroll position for all containers\n\t\tconst containers = queryAll(this.options.scrollContainers).map((el) => ({\n\t\t\ttop: el.scrollTop,\n\t\t\tleft: el.scrollLeft\n\t\t}));\n\n\t\t// construct the final object entry, with the window scroll positions added\n\t\tconst positions = {\n\t\t\twindow: { top: window.scrollY, left: window.scrollX },\n\t\t\tcontainers\n\t\t};\n\n\t\tthis.cachedScrollPositions[cacheKey] = positions;\n\t}\n\n\t/**\n\t * Resets stored scroll positions for a given URL\n\t */\n\tresetScrollPositions(url: string): void {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\t\tdelete this.cachedScrollPositions[cacheKey];\n\t}\n\n\t/**\n\t * Get the stored scroll positions for a given URL from the cache\n\t */\n\tgetCachedScrollPositions(url: string): ScrollPositionsCacheEntry | undefined {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\t\treturn this.cachedScrollPositions[cacheKey];\n\t}\n\n\t/**\n\t * Restore the scroll positions for all matching scrollContainers\n\t */\n\trestoreScrollContainers(url: string): void {\n\t\t// get the stored scroll positions from the cache\n\t\tconst scrollPositions = this.getCachedScrollPositions(url);\n\t\tif (!scrollPositions || scrollPositions.containers.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// cycle through all containers on the current page and restore their scroll positions, if appropriate\n\t\tqueryAll(this.options.scrollContainers).forEach((el, index) => {\n\t\t\tconst scrollPosition = scrollPositions.containers[index];\n\t\t\tif (scrollPosition == null) return;\n\t\t\tel.scrollTop = scrollPosition.top;\n\t\t\tel.scrollLeft = scrollPosition.left;\n\t\t});\n\t}\n\n\tupdateScrollTarget(): void {\n\t\tconst { hash } = window.location;\n\t\tconst currentTarget = document.querySelector('[data-swup-scroll-target]');\n\t\tlet newTarget = this.getAnchorElement(hash);\n\t\tif (newTarget instanceof HTMLBodyElement) {\n\t\t\t// Special case: '#top' fragment returns <body> element\n\t\t\tnewTarget = null;\n\t\t}\n\t\tif (currentTarget === newTarget) {\n\t\t\treturn;\n\t\t}\n\t\tcurrentTarget?.removeAttribute('data-swup-scroll-target');\n\t\tnewTarget?.setAttribute('data-swup-scroll-target', '');\n\t}\n}\n"],"names":["n","r","String","split","map","parseInt","concat","slice","join","e","every","t","s","match","o","i","localeCompare","numeric","constructor","this","_raf","_positionY","_velocityY","_targetPositionY","_targetPositionYWithOffset","_direction","scrollTo","nodeType","Math","round","getBoundingClientRect","top","window","pageYOffset","console","error","document","documentElement","scrollHeight","innerHeight","body","scrollTop","options","onStart","_animate","onAlreadyAtPositions","_update","_render","requestAnimationFrame","onTick","onEnd","acceleration","friction","abs","onCancel","addEventListener","cancelAnimationFrame","passive","Plugin","_this","super","name","requires","swup","scrl","defaults","doScrollingRightAway","animateScroll","betweenPages","samePageWithHash","samePage","scrollFriction","scrollAcceleration","getAnchorElement","undefined","offset","scrollContainers","shouldResetScrollPosition","markScrollTarget","cachedScrollPositions","previousScrollRestoration","currentCacheKey","hash","getOffset","el","onBeforeLinkToSelf","visit","scroll","animate","shouldAnimate","handleScrollToTop","onBeforeLinkToAnchor","handleScrollToAnchor","_ref","maybeScrollToAnchor","onBeforeVisitStart","scrolledToContent","onVisitStart","cacheScrollPositions","from","url","maybeResetScrollPositions","target","to","doScrollingBetweenPages","handleScrollToContent","restoreScrollContainers","history","popstate","animation","scrollTarget","reset","scrollPositions","getCachedScrollPositions","trigger","resetScrollPositions","mount","_this2","hooks","create","createVisit","currentPageUrl","Scrl","callSync","scrollRestoration","animateHistoryBrowsing","updateScrollTarget","bind","on","before","priority","replace","unmount","removeEventListener","context","element","warn","Element","elementTop","scrollY","cacheKey","resolveUrl","containers","queryAll","left","scrollLeft","positions","scrollX","length","forEach","index","scrollPosition","location","currentTarget","querySelector","newTarget","HTMLBodyElement","removeAttribute","setAttribute"],"mappings":"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"}