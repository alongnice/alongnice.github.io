{"version":3,"file":"index.modern.js","sources":["../src/index.ts"],"sourcesContent":["import Plugin from '@swup/plugin';\nimport { Handler, Visit, queryAll } from 'swup';\n// @ts-expect-error\nimport Scrl from 'scrl';\n\nexport type Options = {\n\tdoScrollingRightAway: boolean;\n\tanimateScroll: {\n\t\tbetweenPages: boolean;\n\t\tsamePageWithHash: boolean;\n\t\tsamePage: boolean;\n\t};\n\tscrollFriction: number;\n\tscrollAcceleration: number;\n\tgetAnchorElement?: (hash: string) => Element | null;\n\toffset: number | ((el: Element) => number);\n\tscrollContainers: `[data-swup-scroll-container]`;\n\tshouldResetScrollPosition: (trigger: Element) => boolean;\n\tmarkScrollTarget?: boolean;\n};\n\ntype ScrollPosition = {\n\ttop: number;\n\tleft: number;\n};\n\ntype ScrollPositionsCacheEntry = {\n\twindow: ScrollPosition;\n\tcontainers: ScrollPosition[];\n};\n\ntype ScrollPositionsCache = Record<string, ScrollPositionsCacheEntry>;\n\ndeclare module 'swup' {\n\texport interface Swup {\n\t\tscrollTo?: (offset: number, animate?: boolean) => void;\n\t}\n\n\texport interface VisitScroll {\n\t\t/** Whether scrolling is animated. Set by Scroll Plugin. */\n\t\tanimate?: boolean;\n\t\t/** Whether the scroll position was reset after page load. Set by Scroll Plugin. */\n\t\tscrolledToContent?: boolean;\n\t}\n\n\texport interface HookDefinitions {\n\t\t'scroll:start': undefined;\n\t\t'scroll:end': undefined;\n\t}\n}\n\n/**\n * Scroll Plugin\n */\nexport default class SwupScrollPlugin extends Plugin {\n\tname = 'SwupScrollPlugin';\n\n\trequires = { swup: '>=4.2.0' };\n\n\tscrl: any;\n\n\tdefaults: Options = {\n\t\tdoScrollingRightAway: false,\n\t\tanimateScroll: {\n\t\t\tbetweenPages: true,\n\t\t\tsamePageWithHash: true,\n\t\t\tsamePage: true\n\t\t},\n\t\tscrollFriction: 0.3,\n\t\tscrollAcceleration: 0.04,\n\t\tgetAnchorElement: undefined,\n\t\toffset: 0,\n\t\tscrollContainers: `[data-swup-scroll-container]`,\n\t\tshouldResetScrollPosition: () => true,\n\t\tmarkScrollTarget: false\n\t};\n\n\toptions: Options;\n\n\tcachedScrollPositions: ScrollPositionsCache = {};\n\tpreviousScrollRestoration?: ScrollRestoration;\n\tcurrentCacheKey?: string;\n\n\tconstructor(options: Partial<Options> = {}) {\n\t\tsuper();\n\t\tthis.options = { ...this.defaults, ...options };\n\t}\n\n\tmount() {\n\t\tconst swup = this.swup;\n\n\t\tswup.hooks.create('scroll:start');\n\t\tswup.hooks.create('scroll:end');\n\n\t\t// @ts-expect-error: createVisit is currently private, need to make this semi-public somehow\n\t\tconst visit = this.swup.createVisit({ to: this.swup.currentPageUrl });\n\n\t\t// Initialize Scrl lib for smooth animations\n\t\tthis.scrl = new Scrl({\n\t\t\tonStart: () => swup.hooks.callSync('scroll:start', visit, undefined),\n\t\t\tonEnd: () => swup.hooks.callSync('scroll:end', visit, undefined),\n\t\t\tonCancel: () => swup.hooks.callSync('scroll:end', visit, undefined),\n\t\t\tfriction: this.options.scrollFriction,\n\t\t\tacceleration: this.options.scrollAcceleration\n\t\t});\n\n\t\t// Add scrollTo method to swup and animate based on current animateScroll option\n\t\tswup.scrollTo = (offset, animate = true) => {\n\t\t\tif (animate) {\n\t\t\t\tthis.scrl.scrollTo(offset);\n\t\t\t} else {\n\t\t\t\tswup.hooks.callSync('scroll:start', visit, undefined);\n\t\t\t\twindow.scrollTo(0, offset);\n\t\t\t\tswup.hooks.callSync('scroll:end', visit, undefined);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Disable browser scroll restoration for history visits\n\t\t * if `swup.options.animateHistoryBrowsing` is true\n\t\t * Store the previous setting to be able to properly restore it on unmount\n\t\t */\n\t\tthis.previousScrollRestoration = window.history.scrollRestoration;\n\t\tif (swup.options.animateHistoryBrowsing) {\n\t\t\twindow.history.scrollRestoration = 'manual';\n\t\t}\n\n\t\t/**\n\t\t * Mark the current scroll target element with a `data-swup-scroll-target` attribute\n\t\t */\n\t\tthis.updateScrollTarget = this.updateScrollTarget.bind(this);\n\t\tif (this.options.markScrollTarget) {\n\t\t\twindow.addEventListener('popstate', this.updateScrollTarget);\n\t\t\twindow.addEventListener('hashchange', this.updateScrollTarget);\n\t\t\tthis.on('page:view', this.updateScrollTarget);\n\t\t\tthis.on('link:anchor', this.updateScrollTarget);\n\t\t\tthis.on('link:self', this.updateScrollTarget);\n\t\t\tthis.updateScrollTarget();\n\t\t}\n\n\t\t// scroll to the top of the page when a visit starts, before replacing the content\n\t\tthis.before('visit:start', this.onBeforeVisitStart, { priority: -1 });\n\t\tthis.on('visit:start', this.onVisitStart, { priority: 1 });\n\n\t\t// scroll to the top or target element after replacing the content\n\t\tthis.replace('content:scroll', this.handleScrollToContent);\n\n\t\t// scroll to the top of the same page\n\t\tthis.before('link:self', this.onBeforeLinkToSelf, { priority: -1 });\n\t\tthis.replace('scroll:top', this.handleScrollToTop);\n\n\t\t// scroll to an anchor on the same page\n\t\tthis.before('link:anchor', this.onBeforeLinkToAnchor, { priority: -1 });\n\t\tthis.replace('scroll:anchor', this.handleScrollToAnchor);\n\t}\n\n\t/**\n\t * Runs when the plugin is unmounted\n\t */\n\tunmount() {\n\t\tsuper.unmount();\n\n\t\tif (this.previousScrollRestoration) {\n\t\t\twindow.history.scrollRestoration = this.previousScrollRestoration;\n\t\t}\n\n\t\twindow.removeEventListener('popstate', this.updateScrollTarget);\n\t\twindow.removeEventListener('hashchange', this.updateScrollTarget);\n\n\t\tthis.cachedScrollPositions = {};\n\t\tdelete this.swup.scrollTo;\n\t\tdelete this.scrl;\n\t}\n\n\t/**\n\t * Detects if a scroll should be animated, based on context\n\t */\n\tshouldAnimate(context: keyof Options['animateScroll']): boolean {\n\t\tif (typeof this.options.animateScroll === 'boolean') {\n\t\t\treturn this.options.animateScroll;\n\t\t}\n\t\treturn this.options.animateScroll[context];\n\t}\n\n\t/**\n\t * Get an element based on anchor\n\t */\n\tgetAnchorElement = (hash: string = ''): Element | null => {\n\t\t// Look for a custom function provided via the plugin options\n\t\tif (typeof this.options.getAnchorElement === 'function') {\n\t\t\treturn this.options.getAnchorElement(hash);\n\t\t}\n\n\t\treturn this.swup.getAnchorElement(hash);\n\t};\n\n\t/**\n\t * Get the offset for a scroll\n\t */\n\tgetOffset = (el?: Element): number => {\n\t\tif (!el) return 0;\n\t\t// If options.offset is a function, apply and return it\n\t\tif (typeof this.options.offset === 'function') {\n\t\t\treturn parseInt(String(this.options.offset(el)), 10);\n\t\t}\n\t\t// Otherwise, return the sanitized offset\n\t\treturn parseInt(String(this.options.offset), 10);\n\t};\n\n\t/**\n\t * Store scroll animation status in visit object before scrolling up\n\t */\n\tonBeforeLinkToSelf: Handler<'link:self'> = (visit) => {\n\t\tvisit.scroll.animate = this.shouldAnimate('samePage');\n\t};\n\n\t/**\n\t * Scroll to top on `scroll:top` hook\n\t */\n\thandleScrollToTop: Handler<'scroll:top'> = (visit) => {\n\t\tthis.swup.scrollTo?.(0, visit.scroll.animate);\n\t\treturn true;\n\t};\n\n\t/**\n\t * Store scroll animation status in visit object before scrolling to anchor\n\t */\n\tonBeforeLinkToAnchor: Handler<'link:anchor'> = (visit) => {\n\t\tvisit.scroll.animate = this.shouldAnimate('samePageWithHash');\n\t};\n\n\t/**\n\t * Scroll to anchor on `scroll:anchor` hook\n\t */\n\thandleScrollToAnchor: Handler<'scroll:anchor'> = (visit, { hash }) => {\n\t\treturn this.maybeScrollToAnchor(hash, visit.scroll.animate);\n\t};\n\n\t/**\n\t * Attempts to scroll to an anchor\n\t */\n\tmaybeScrollToAnchor(hash?: string, animate: boolean = false): boolean {\n\t\tif (!hash) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst element = this.getAnchorElement(hash);\n\t\tif (!element) {\n\t\t\tconsole.warn(`Anchor target ${hash} not found`);\n\t\t\treturn false;\n\t\t}\n\t\tif (!(element instanceof Element)) {\n\t\t\tconsole.warn(`Anchor target ${hash} is not a DOM node`);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { top: elementTop } = element.getBoundingClientRect();\n\t\tconst top = elementTop + window.scrollY - this.getOffset(element);\n\t\tthis.swup.scrollTo?.(top, animate);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Prepare scrolling before visit:start hook\n\t */\n\tonBeforeVisitStart: Handler<'visit:start'> = (visit) => {\n\t\tvisit.scroll.scrolledToContent = false;\n\t\tvisit.scroll.animate = this.shouldAnimate('betweenPages');\n\t};\n\n\t/**\n\t * Check whether to scroll in `visit:start` hook\n\t */\n\tonVisitStart: Handler<'visit:start'> = (visit) => {\n\t\tthis.cacheScrollPositions(visit.from.url);\n\t\tthis.maybeResetScrollPositions(visit);\n\n\t\tconst scrollTarget = visit.scroll.target ?? visit.to.hash;\n\n\t\t// Conditions for scrolling before content replace:\n\t\t// - scroll is animated (otherwise the effect is useless)\n\t\t// - no scroll target is defined (needs to wait until new content is there)\n\t\tif (visit.scroll.animate && this.options.doScrollingRightAway && !scrollTarget) {\n\t\t\tthis.doScrollingBetweenPages(visit);\n\t\t}\n\t};\n\n\t/**\n\t * Check whether to scroll in `content:scroll` hook\n\t */\n\thandleScrollToContent: Handler<'content:scroll'> = (visit) => {\n\t\tif (!visit.scroll.scrolledToContent) {\n\t\t\tthis.doScrollingBetweenPages(visit);\n\t\t}\n\t\tthis.restoreScrollContainers(visit.to.url);\n\t};\n\n\t/**\n\t * Scrolls the window\n\t */\n\tdoScrollingBetweenPages = (visit: Visit): void => {\n\t\t// Bail early on popstate if not animated: browser will handle it\n\t\tif (visit.history.popstate && !visit.animation.animate) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Try scrolling to a given anchor\n\t\tconst scrollTarget = visit.scroll.target ?? visit.to.hash;\n\t\tif (scrollTarget && this.maybeScrollToAnchor(scrollTarget, visit.scroll.animate)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Allow not resetting scroll position\n\t\tif (!visit.scroll.reset) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Finally, scroll to either the stored scroll position or to the very top of the page\n\t\tconst scrollPositions = this.getCachedScrollPositions(visit.to.url);\n\t\tconst top = scrollPositions?.window?.top || 0;\n\n\t\t// Give possible JavaScript time to execute before scrolling\n\t\trequestAnimationFrame(() => this.swup.scrollTo?.(top, visit.scroll.animate));\n\n\t\tvisit.scroll.scrolledToContent = true;\n\t};\n\n\t/**\n\t * Reset cached scroll positions. Do not reset if:\n\t * - the visit is a history visit\n\t * - the visit is triggered by a link and shouldResetScrollPosition(link) returns false\n\t */\n\tmaybeResetScrollPositions = (visit: Visit): void => {\n\t\tconst { popstate } = visit.history;\n\t\tconst { url } = visit.to;\n\t\tconst { el } = visit.trigger;\n\t\tif (popstate) {\n\t\t\treturn;\n\t\t}\n\t\tif (el && !this.options.shouldResetScrollPosition(el)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.resetScrollPositions(url);\n\t};\n\n\t/**\n\t * Stores the scroll positions for the current URL\n\t */\n\tcacheScrollPositions(url: string): void {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\n\t\t// retrieve the current scroll position for all containers\n\t\tconst containers = queryAll(this.options.scrollContainers).map((el) => ({\n\t\t\ttop: el.scrollTop,\n\t\t\tleft: el.scrollLeft\n\t\t}));\n\n\t\t// construct the final object entry, with the window scroll positions added\n\t\tconst positions = {\n\t\t\twindow: { top: window.scrollY, left: window.scrollX },\n\t\t\tcontainers\n\t\t};\n\n\t\tthis.cachedScrollPositions[cacheKey] = positions;\n\t}\n\n\t/**\n\t * Resets stored scroll positions for a given URL\n\t */\n\tresetScrollPositions(url: string): void {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\t\tdelete this.cachedScrollPositions[cacheKey];\n\t}\n\n\t/**\n\t * Get the stored scroll positions for a given URL from the cache\n\t */\n\tgetCachedScrollPositions(url: string): ScrollPositionsCacheEntry | undefined {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\t\treturn this.cachedScrollPositions[cacheKey];\n\t}\n\n\t/**\n\t * Restore the scroll positions for all matching scrollContainers\n\t */\n\trestoreScrollContainers(url: string): void {\n\t\t// get the stored scroll positions from the cache\n\t\tconst scrollPositions = this.getCachedScrollPositions(url);\n\t\tif (!scrollPositions || scrollPositions.containers.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// cycle through all containers on the current page and restore their scroll positions, if appropriate\n\t\tqueryAll(this.options.scrollContainers).forEach((el, index) => {\n\t\t\tconst scrollPosition = scrollPositions.containers[index];\n\t\t\tif (scrollPosition == null) return;\n\t\t\tel.scrollTop = scrollPosition.top;\n\t\t\tel.scrollLeft = scrollPosition.left;\n\t\t});\n\t}\n\n\tupdateScrollTarget(): void {\n\t\tconst { hash } = window.location;\n\t\tconst currentTarget = document.querySelector('[data-swup-scroll-target]');\n\t\tlet newTarget = this.getAnchorElement(hash);\n\t\tif (newTarget instanceof HTMLBodyElement) {\n\t\t\t// Special case: '#top' fragment returns <body> element\n\t\t\tnewTarget = null;\n\t\t}\n\t\tif (currentTarget === newTarget) {\n\t\t\treturn;\n\t\t}\n\t\tcurrentTarget?.removeAttribute('data-swup-scroll-target');\n\t\tnewTarget?.setAttribute('data-swup-scroll-target', '');\n\t}\n}\n"],"names":["SwupScrollPlugin","Plugin","constructor","options","super","this","name","requires","swup","scrl","defaults","doScrollingRightAway","animateScroll","betweenPages","samePageWithHash","samePage","scrollFriction","scrollAcceleration","getAnchorElement","undefined","offset","scrollContainers","shouldResetScrollPosition","markScrollTarget","cachedScrollPositions","previousScrollRestoration","currentCacheKey","hash","getOffset","el","parseInt","String","onBeforeLinkToSelf","visit","scroll","animate","shouldAnimate","handleScrollToTop","_this$swup$scrollTo","_this$swup","scrollTo","call","onBeforeLinkToAnchor","handleScrollToAnchor","maybeScrollToAnchor","onBeforeVisitStart","scrolledToContent","onVisitStart","_visit$scroll$target","cacheScrollPositions","from","url","maybeResetScrollPositions","scrollTarget","target","to","doScrollingBetweenPages","handleScrollToContent","restoreScrollContainers","_visit$scroll$target2","_scrollPositions$wind","history","popstate","animation","reset","scrollPositions","getCachedScrollPositions","top","window","requestAnimationFrame","_this$swup$scrollTo2","_this$swup2","trigger","resetScrollPositions","_extends","mount","hooks","create","createVisit","currentPageUrl","Scrl","onStart","callSync","onEnd","onCancel","friction","acceleration","scrollRestoration","animateHistoryBrowsing","updateScrollTarget","bind","addEventListener","on","before","priority","replace","unmount","removeEventListener","context","_this$swup$scrollTo3","_this$swup3","element","console","warn","Element","elementTop","getBoundingClientRect","scrollY","cacheKey","resolveUrl","containers","queryAll","map","scrollTop","left","scrollLeft","positions","scrollX","length","forEach","index","scrollPosition","_newTarget","location","currentTarget","document","querySelector","newTarget","HTMLBodyElement","removeAttribute","setAttribute"],"mappings":"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"}