{"version":3,"file":"index.umd.js","sources":["../node_modules/@swup/plugin/dist/index.modern.js","../src/index.ts"],"sourcesContent":["function r(){return r=Object.assign?Object.assign.bind():function(r){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=e[t])}return r},r.apply(this,arguments)}const n=r=>String(r).split(\".\").map(r=>String(parseInt(r||\"0\",10))).concat([\"0\",\"0\"]).slice(0,3).join(\".\");class e{constructor(){this.isSwupPlugin=!0,this.swup=void 0,this.version=void 0,this.requires={},this.handlersToUnregister=[]}mount(){}unmount(){this.handlersToUnregister.forEach(r=>r()),this.handlersToUnregister=[]}_beforeMount(){if(!this.name)throw new Error(\"You must define a name of plugin when creating a class.\")}_afterUnmount(){}_checkRequirements(){return\"object\"!=typeof this.requires||Object.entries(this.requires).forEach(([r,e])=>{if(!function(r,e,t){const s=function(r,n){var e;if(\"swup\"===r)return null!=(e=n.version)?e:\"\";{var t;const e=n.findPlugin(r);return null!=(t=null==e?void 0:e.version)?t:\"\"}}(r,t);return!!s&&((r,e)=>e.every(e=>{const[,t,s]=e.match(/^([\\D]+)?(.*)$/)||[];var o,i;return((r,n)=>{const e={\"\":r=>0===r,\">\":r=>r>0,\">=\":r=>r>=0,\"<\":r=>r<0,\"<=\":r=>r<=0};return(e[n]||e[\"\"])(r)})((i=s,o=n(o=r),i=n(i),o.localeCompare(i,void 0,{numeric:!0})),t||\">=\")}))(s,e)}(r,e=Array.isArray(e)?e:[e],this.swup)){const n=`${r} ${e.join(\", \")}`;throw new Error(`Plugin version mismatch: ${this.name} requires ${n}`)}}),!0}on(r,n,e={}){var t;n=!(t=n).name.startsWith(\"bound \")||t.hasOwnProperty(\"prototype\")?n.bind(this):n;const s=this.swup.hooks.on(r,n,e);return this.handlersToUnregister.push(s),s}once(n,e,t={}){return this.on(n,e,r({},t,{once:!0}))}before(n,e,t={}){return this.on(n,e,r({},t,{before:!0}))}replace(n,e,t={}){return this.on(n,e,r({},t,{replace:!0}))}off(r,n){return this.swup.hooks.off(r,n)}}export{e as default};\n//# sourceMappingURL=index.modern.js.map\n","import type { Handler, PageData, Visit } from 'swup';\nimport { forceReflow } from 'swup';\nimport Plugin from '@swup/plugin';\n\ndeclare module 'swup' {\n\texport interface HookDefinitions {\n\t\t'content:insert': { containers: ContainerSet[] };\n\t\t'content:remove': { containers: ContainerSet[] };\n\t}\n\texport interface VisitAnimation {\n\t\t/** Parallel visit: run in and out animation at the same time */\n\t\tparallel?: boolean;\n\t}\n}\n\ntype PluginOptions = {\n\t/** Containers to animate in parallel */\n\tcontainers: string[];\n\t/** Number of previous containers to keep around after the animation */\n\tkeep: number | { [container: string]: number };\n};\n\ntype ContainerSet = {\n\t/** Selector to match this container */\n\tselector: string;\n\t/** Incoming container element */\n\tnext: HTMLElement;\n\t/** Outgoing container element */\n\tprevious: HTMLElement;\n\t/** Container elements to keep around after the animation */\n\tkeep: HTMLElement[];\n\t/** Container elements to remove after the animation */\n\tremove: HTMLElement[];\n\t/** All container elements associated with this selector */\n\tall: HTMLElement[];\n};\n\nexport default class SwupParallelPlugin extends Plugin {\n\tname = 'SwupParallelPlugin';\n\n\trequires = { swup: '>=4.6' };\n\n\tdefaults: PluginOptions = {\n\t\tcontainers: [],\n\t\tkeep: 0\n\t};\n\n\toptions: PluginOptions;\n\n\toriginalContainers: string[] | null = null;\n\tparallelContainers: ContainerSet[] = [];\n\n\tconstructor(options: Partial<PluginOptions> = {}) {\n\t\tsuper();\n\t\tthis.options = { ...this.defaults, ...options };\n\t}\n\n\tmount() {\n\t\t// No containers passed? Use all content containers\n\t\tif (!this.options.containers.length) {\n\t\t\tthis.options.containers = this.swup.options.containers;\n\t\t}\n\n\t\t// Create new hooks\n\t\tthis.swup.hooks.create('content:insert');\n\t\tthis.swup.hooks.create('content:remove');\n\n\t\t// On visit: check for containers and mark as parallel visit\n\t\t// Run after user hooks to allow disabling parallel animations beforehand\n\t\tthis.on('visit:start', this.startVisit, { priority: 1 });\n\n\t\t// Before awaiting out animation: skip\n\t\tthis.before('animation:out:await', this.skipOutAnimation, { priority: 1 });\n\n\t\t// Before content replace: insert new containers\n\t\tthis.before('content:replace', this.insertContainers, { priority: 1 });\n\n\t\t// After content replace: reset containers\n\t\tthis.on('content:replace', this.resetContainers);\n\n\t\t// After visit: remove old containers\n\t\tthis.on('visit:end', this.cleanupContainers);\n\t}\n\n\t/** On visit start: mark visit as parallel if conditions match */\n\tprotected startVisit: Handler<'visit:start'> = (visit) => {\n\t\tthis.originalContainers = null;\n\n\t\t// Only mark as parallel visit if containers found and animation matches\n\t\tif (this.visitHasPotentialParallelAnimation(visit)) {\n\t\t\tvisit.animation.wait = true;\n\t\t\tvisit.animation.parallel = true;\n\t\t}\n\t};\n\n\t/** On animation out: skip animation if parallel visit */\n\tprotected skipOutAnimation: Handler<'animation:out:await'> = (visit, args) => {\n\t\tif (this.isParallelVisit(visit)) {\n\t\t\targs.skip = true;\n\t\t}\n\t};\n\n\t/** Before content replacement: insert new containers */\n\tprotected insertContainers: Handler<'content:replace'> = (visit) => {\n\t\tif (!this.isParallelVisit(visit)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Get info about parallel containers and save for later cleanup\n\t\tconst containers = this.getParallelContainersForVisit(visit);\n\t\tthis.parallelContainers = containers;\n\n\t\t// Replace parallel containers ourselves\n\t\tthis.swup.hooks.call('content:insert', { containers }, () => {\n\t\t\tfor (const { all, next, previous, keep, remove } of containers) {\n\t\t\t\tall.forEach((el, i) => el.style.setProperty('--swup-parallel-container', `${i}`));\n\t\t\t\tprevious.setAttribute('aria-hidden', 'true');\n\t\t\t\tprevious.before(next);\n\n\t\t\t\tif (visit.animation.animate) {\n\t\t\t\t\tnext.classList.add('is-next-container');\n\t\t\t\t\tforceReflow(next);\n\t\t\t\t\tnext.classList.remove('is-next-container');\n\t\t\t\t}\n\n\t\t\t\tprevious.classList.add('is-previous-container');\n\t\t\t\tkeep.forEach((el) => el.classList.add('is-kept-container'));\n\t\t\t\tremove.forEach((el) => el.classList.add('is-removing-container'));\n\t\t\t}\n\t\t});\n\n\t\t// Modify visit containers so swup will only replace non-parallel containers\n\t\tthis.originalContainers = visit.containers;\n\t\tconst parallelSelectors = this.parallelContainers.map(({ selector }) => selector);\n\t\tvisit.containers = visit.containers.filter((s) => !parallelSelectors.includes(s));\n\t};\n\n\t/** After content replacement: restore original container selectors */\n\tprotected resetContainers: Handler<'content:replace'> = (visit) => {\n\t\tif (this.originalContainers) {\n\t\t\tvisit.containers = this.originalContainers;\n\t\t}\n\t};\n\n\t/** After each visit: remove previous containers */\n\tprotected cleanupContainers = () => {\n\t\tconst containers = this.parallelContainers;\n\t\tthis.swup.hooks.call('content:remove', { containers }, () => {\n\t\t\tfor (const { remove, next } of containers) {\n\t\t\t\tremove.forEach((el) => el.remove());\n\t\t\t\tnext.classList.remove('is-next-container');\n\t\t\t}\n\t\t});\n\t\tthis.parallelContainers = [];\n\t};\n\n\t/** Get all container sets for this visit from the current page and the incoming html */\n\tprotected getParallelContainersForVisit(visit: Visit): ContainerSet[] {\n\t\tconst { containers: parallelContainers } = this.options;\n\n\t\tconst containersInVisit = parallelContainers.filter((s) => visit.containers.includes(s));\n\t\tif (!containersInVisit.length) {\n\t\t\tconsole.warn('No parallel containers found in list of replaced containers');\n\t\t\treturn [];\n\t\t}\n\n\t\treturn containersInVisit.reduce((containers, selector: string) => {\n\t\t\tlet { keep: keepCount } = this.options;\n\t\t\tkeepCount = typeof keepCount === 'object' ? keepCount[selector] : keepCount;\n\t\t\tkeepCount = Math.max(0, Number(keepCount));\n\n\t\t\tconst next = visit.to.document!.querySelector<HTMLElement>(selector);\n\t\t\tconst previousAll = Array.from(document.querySelectorAll<HTMLElement>(selector));\n\n\t\t\tconst previous = previousAll[0];\n\t\t\tconst keep = previousAll.slice(0, keepCount);\n\t\t\tconst remove = previousAll.slice(keepCount);\n\t\t\tconst all = [...new Set([next!, previous, ...keep, ...remove])];\n\t\t\tif (next && previous) {\n\t\t\t\treturn [...containers, { selector, next, previous, keep, remove, all }];\n\t\t\t} else {\n\t\t\t\tconsole.warn(`Parallel container ${selector} not found`);\n\t\t\t\treturn containers;\n\t\t\t}\n\t\t}, [] as ContainerSet[]);\n\t}\n\n\t/** Check if a visit is marked as parallel animation */\n\tprotected isParallelVisit(visit: Visit) {\n\t\treturn visit.animation.parallel;\n\t}\n\n\t/** Mark a visit as parallel animation */\n\tprotected markVisitAsParallelAnimation(visit: Visit) {\n\t\tvisit.animation.wait = true;\n\t\tvisit.animation.parallel = true;\n\t}\n\n\t/** Check if a visit is potentially parallel */\n\tprotected visitHasPotentialParallelAnimation(visit: Visit) {\n\t\t// Checking for visit.animation.parallel !== false here allows explicitly\n\t\t// disabling parallel animations in user hooks before this plugin executes\n\t\treturn visit.animation.parallel !== false && this.visitHasParallelContainers(visit);\n\t}\n\n\t/** Check if any of a visit's containers are animated in parallel */\n\tprotected visitHasParallelContainers(visit: Visit) {\n\t\treturn this.options.containers.some((selector) => {\n\t\t\tconst container = document.querySelector(selector);\n\t\t\treturn container?.matches(visit.containers.join(','));\n\t\t});\n\t}\n}\n"],"names":["n","r","String","split","map","parseInt","concat","slice","join","e","every","t","s","match","o","i","localeCompare","numeric","Plugin","constructor","options","super","this","name","requires","swup","defaults","containers","keep","originalContainers","parallelContainers","startVisit","visit","visitHasPotentialParallelAnimation","animation","wait","parallel","skipOutAnimation","args","isParallelVisit","skip","insertContainers","getParallelContainersForVisit","hooks","call","all","next","previous","remove","forEach","el","style","setProperty","setAttribute","before","animate","classList","add","forceReflow","parallelSelectors","_ref","selector","filter","includes","resetContainers","cleanupContainers","mount","length","create","on","priority","containersInVisit","reduce","keepCount","Math","max","Number","to","document","querySelector","previousAll","Array","from","querySelectorAll","Set","console","warn","markVisitAsParallelAnimation","visitHasParallelContainers","some","container","matches"],"mappings":"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"}