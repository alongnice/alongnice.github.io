{"version":3,"file":"index.module.js","sources":["../src/index.ts"],"sourcesContent":["import type { Handler, PageData, Visit } from 'swup';\nimport { forceReflow } from 'swup';\nimport Plugin from '@swup/plugin';\n\ndeclare module 'swup' {\n\texport interface HookDefinitions {\n\t\t'content:insert': { containers: ContainerSet[] };\n\t\t'content:remove': { containers: ContainerSet[] };\n\t}\n\texport interface VisitAnimation {\n\t\t/** Parallel visit: run in and out animation at the same time */\n\t\tparallel?: boolean;\n\t}\n}\n\ntype PluginOptions = {\n\t/** Containers to animate in parallel */\n\tcontainers: string[];\n\t/** Number of previous containers to keep around after the animation */\n\tkeep: number | { [container: string]: number };\n};\n\ntype ContainerSet = {\n\t/** Selector to match this container */\n\tselector: string;\n\t/** Incoming container element */\n\tnext: HTMLElement;\n\t/** Outgoing container element */\n\tprevious: HTMLElement;\n\t/** Container elements to keep around after the animation */\n\tkeep: HTMLElement[];\n\t/** Container elements to remove after the animation */\n\tremove: HTMLElement[];\n\t/** All container elements associated with this selector */\n\tall: HTMLElement[];\n};\n\nexport default class SwupParallelPlugin extends Plugin {\n\tname = 'SwupParallelPlugin';\n\n\trequires = { swup: '>=4.6' };\n\n\tdefaults: PluginOptions = {\n\t\tcontainers: [],\n\t\tkeep: 0\n\t};\n\n\toptions: PluginOptions;\n\n\toriginalContainers: string[] | null = null;\n\tparallelContainers: ContainerSet[] = [];\n\n\tconstructor(options: Partial<PluginOptions> = {}) {\n\t\tsuper();\n\t\tthis.options = { ...this.defaults, ...options };\n\t}\n\n\tmount() {\n\t\t// No containers passed? Use all content containers\n\t\tif (!this.options.containers.length) {\n\t\t\tthis.options.containers = this.swup.options.containers;\n\t\t}\n\n\t\t// Create new hooks\n\t\tthis.swup.hooks.create('content:insert');\n\t\tthis.swup.hooks.create('content:remove');\n\n\t\t// On visit: check for containers and mark as parallel visit\n\t\t// Run after user hooks to allow disabling parallel animations beforehand\n\t\tthis.on('visit:start', this.startVisit, { priority: 1 });\n\n\t\t// Before awaiting out animation: skip\n\t\tthis.before('animation:out:await', this.skipOutAnimation, { priority: 1 });\n\n\t\t// Before content replace: insert new containers\n\t\tthis.before('content:replace', this.insertContainers, { priority: 1 });\n\n\t\t// After content replace: reset containers\n\t\tthis.on('content:replace', this.resetContainers);\n\n\t\t// After visit: remove old containers\n\t\tthis.on('visit:end', this.cleanupContainers);\n\t}\n\n\t/** On visit start: mark visit as parallel if conditions match */\n\tprotected startVisit: Handler<'visit:start'> = (visit) => {\n\t\tthis.originalContainers = null;\n\n\t\t// Only mark as parallel visit if containers found and animation matches\n\t\tif (this.visitHasPotentialParallelAnimation(visit)) {\n\t\t\tvisit.animation.wait = true;\n\t\t\tvisit.animation.parallel = true;\n\t\t}\n\t};\n\n\t/** On animation out: skip animation if parallel visit */\n\tprotected skipOutAnimation: Handler<'animation:out:await'> = (visit, args) => {\n\t\tif (this.isParallelVisit(visit)) {\n\t\t\targs.skip = true;\n\t\t}\n\t};\n\n\t/** Before content replacement: insert new containers */\n\tprotected insertContainers: Handler<'content:replace'> = (visit) => {\n\t\tif (!this.isParallelVisit(visit)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Get info about parallel containers and save for later cleanup\n\t\tconst containers = this.getParallelContainersForVisit(visit);\n\t\tthis.parallelContainers = containers;\n\n\t\t// Replace parallel containers ourselves\n\t\tthis.swup.hooks.call('content:insert', { containers }, () => {\n\t\t\tfor (const { all, next, previous, keep, remove } of containers) {\n\t\t\t\tall.forEach((el, i) => el.style.setProperty('--swup-parallel-container', `${i}`));\n\t\t\t\tprevious.setAttribute('aria-hidden', 'true');\n\t\t\t\tprevious.before(next);\n\n\t\t\t\tif (visit.animation.animate) {\n\t\t\t\t\tnext.classList.add('is-next-container');\n\t\t\t\t\tforceReflow(next);\n\t\t\t\t\tnext.classList.remove('is-next-container');\n\t\t\t\t}\n\n\t\t\t\tprevious.classList.add('is-previous-container');\n\t\t\t\tkeep.forEach((el) => el.classList.add('is-kept-container'));\n\t\t\t\tremove.forEach((el) => el.classList.add('is-removing-container'));\n\t\t\t}\n\t\t});\n\n\t\t// Modify visit containers so swup will only replace non-parallel containers\n\t\tthis.originalContainers = visit.containers;\n\t\tconst parallelSelectors = this.parallelContainers.map(({ selector }) => selector);\n\t\tvisit.containers = visit.containers.filter((s) => !parallelSelectors.includes(s));\n\t};\n\n\t/** After content replacement: restore original container selectors */\n\tprotected resetContainers: Handler<'content:replace'> = (visit) => {\n\t\tif (this.originalContainers) {\n\t\t\tvisit.containers = this.originalContainers;\n\t\t}\n\t};\n\n\t/** After each visit: remove previous containers */\n\tprotected cleanupContainers = () => {\n\t\tconst containers = this.parallelContainers;\n\t\tthis.swup.hooks.call('content:remove', { containers }, () => {\n\t\t\tfor (const { remove, next } of containers) {\n\t\t\t\tremove.forEach((el) => el.remove());\n\t\t\t\tnext.classList.remove('is-next-container');\n\t\t\t}\n\t\t});\n\t\tthis.parallelContainers = [];\n\t};\n\n\t/** Get all container sets for this visit from the current page and the incoming html */\n\tprotected getParallelContainersForVisit(visit: Visit): ContainerSet[] {\n\t\tconst { containers: parallelContainers } = this.options;\n\n\t\tconst containersInVisit = parallelContainers.filter((s) => visit.containers.includes(s));\n\t\tif (!containersInVisit.length) {\n\t\t\tconsole.warn('No parallel containers found in list of replaced containers');\n\t\t\treturn [];\n\t\t}\n\n\t\treturn containersInVisit.reduce((containers, selector: string) => {\n\t\t\tlet { keep: keepCount } = this.options;\n\t\t\tkeepCount = typeof keepCount === 'object' ? keepCount[selector] : keepCount;\n\t\t\tkeepCount = Math.max(0, Number(keepCount));\n\n\t\t\tconst next = visit.to.document!.querySelector<HTMLElement>(selector);\n\t\t\tconst previousAll = Array.from(document.querySelectorAll<HTMLElement>(selector));\n\n\t\t\tconst previous = previousAll[0];\n\t\t\tconst keep = previousAll.slice(0, keepCount);\n\t\t\tconst remove = previousAll.slice(keepCount);\n\t\t\tconst all = [...new Set([next!, previous, ...keep, ...remove])];\n\t\t\tif (next && previous) {\n\t\t\t\treturn [...containers, { selector, next, previous, keep, remove, all }];\n\t\t\t} else {\n\t\t\t\tconsole.warn(`Parallel container ${selector} not found`);\n\t\t\t\treturn containers;\n\t\t\t}\n\t\t}, [] as ContainerSet[]);\n\t}\n\n\t/** Check if a visit is marked as parallel animation */\n\tprotected isParallelVisit(visit: Visit) {\n\t\treturn visit.animation.parallel;\n\t}\n\n\t/** Mark a visit as parallel animation */\n\tprotected markVisitAsParallelAnimation(visit: Visit) {\n\t\tvisit.animation.wait = true;\n\t\tvisit.animation.parallel = true;\n\t}\n\n\t/** Check if a visit is potentially parallel */\n\tprotected visitHasPotentialParallelAnimation(visit: Visit) {\n\t\t// Checking for visit.animation.parallel !== false here allows explicitly\n\t\t// disabling parallel animations in user hooks before this plugin executes\n\t\treturn visit.animation.parallel !== false && this.visitHasParallelContainers(visit);\n\t}\n\n\t/** Check if any of a visit's containers are animated in parallel */\n\tprotected visitHasParallelContainers(visit: Visit) {\n\t\treturn this.options.containers.some((selector) => {\n\t\t\tconst container = document.querySelector(selector);\n\t\t\treturn container?.matches(visit.containers.join(','));\n\t\t});\n\t}\n}\n"],"names":["SwupParallelPlugin","Plugin","constructor","options","super","this","name","requires","swup","defaults","containers","keep","originalContainers","parallelContainers","startVisit","visit","visitHasPotentialParallelAnimation","animation","wait","parallel","skipOutAnimation","args","isParallelVisit","skip","insertContainers","getParallelContainersForVisit","hooks","call","all","next","previous","remove","forEach","el","i","style","setProperty","setAttribute","before","animate","classList","add","forceReflow","parallelSelectors","map","selector","filter","s","includes","resetContainers","cleanupContainers","mount","length","create","on","priority","containersInVisit","reduce","keepCount","Math","max","Number","to","document","querySelector","previousAll","Array","from","querySelectorAll","slice","Set","console","warn","markVisitAsParallelAnimation","visitHasParallelContainers","some","container","matches","join"],"mappings":"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"}