import{forceReflow as t}from"swup";import i from"@swup/plugin";function n(){return n=Object.assign?Object.assign.bind():function(t){for(var i=1;i<arguments.length;i++){var n=arguments[i];for(var e in n)Object.prototype.hasOwnProperty.call(n,e)&&(t[e]=n[e])}return t},n.apply(this,arguments)}class e extends i{constructor(i={}){super(),this.name="SwupParallelPlugin",this.requires={swup:">=4.6"},this.defaults={containers:[],keep:0},this.options=void 0,this.originalContainers=null,this.parallelContainers=[],this.startVisit=t=>{this.originalContainers=null,this.visitHasPotentialParallelAnimation(t)&&(t.animation.wait=!0,t.animation.parallel=!0)},this.skipOutAnimation=(t,i)=>{this.isParallelVisit(t)&&(i.skip=!0)},this.insertContainers=i=>{if(!this.isParallelVisit(i))return;const n=this.getParallelContainersForVisit(i);this.parallelContainers=n,this.swup.hooks.call("content:insert",{containers:n},()=>{for(const{all:e,next:s,previous:a,keep:o,remove:r}of n)e.forEach((t,i)=>t.style.setProperty("--swup-parallel-container",`${i}`)),a.setAttribute("aria-hidden","true"),a.before(s),i.animation.animate&&(s.classList.add("is-next-container"),t(s),s.classList.remove("is-next-container")),a.classList.add("is-previous-container"),o.forEach(t=>t.classList.add("is-kept-container")),r.forEach(t=>t.classList.add("is-removing-container"))}),this.originalContainers=i.containers;const e=this.parallelContainers.map(({selector:t})=>t);i.containers=i.containers.filter(t=>!e.includes(t))},this.resetContainers=t=>{this.originalContainers&&(t.containers=this.originalContainers)},this.cleanupContainers=()=>{const t=this.parallelContainers;this.swup.hooks.call("content:remove",{containers:t},()=>{for(const{remove:i,next:n}of t)i.forEach(t=>t.remove()),n.classList.remove("is-next-container")}),this.parallelContainers=[]},this.options=n({},this.defaults,i)}mount(){this.options.containers.length||(this.options.containers=this.swup.options.containers),this.swup.hooks.create("content:insert"),this.swup.hooks.create("content:remove"),this.on("visit:start",this.startVisit,{priority:1}),this.before("animation:out:await",this.skipOutAnimation,{priority:1}),this.before("content:replace",this.insertContainers,{priority:1}),this.on("content:replace",this.resetContainers),this.on("visit:end",this.cleanupContainers)}getParallelContainersForVisit(t){const{containers:i}=this.options,n=i.filter(i=>t.containers.includes(i));return n.length?n.reduce((i,n)=>{let{keep:e}=this.options;e="object"==typeof e?e[n]:e,e=Math.max(0,Number(e));const s=t.to.document.querySelector(n),a=Array.from(document.querySelectorAll(n)),o=a[0],r=a.slice(0,e),l=a.slice(e),c=[...new Set([s,o,...r,...l])];return s&&o?[...i,{selector:n,next:s,previous:o,keep:r,remove:l,all:c}]:(console.warn(`Parallel container ${n} not found`),i)},[]):(console.warn("No parallel containers found in list of replaced containers"),[])}isParallelVisit(t){return t.animation.parallel}markVisitAsParallelAnimation(t){t.animation.wait=!0,t.animation.parallel=!0}visitHasPotentialParallelAnimation(t){return!1!==t.animation.parallel&&this.visitHasParallelContainers(t)}visitHasParallelContainers(t){return this.options.containers.some(i=>{const n=document.querySelector(i);return null==n?void 0:n.matches(t.containers.join(","))})}}export{e as default};
//# sourceMappingURL=index.modern.js.map
