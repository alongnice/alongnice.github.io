{"version":3,"file":"index.umd.js","sources":["../node_modules/@swup/plugin/dist/index.modern.js","../node_modules/path-to-regexp/dist.es2015/index.js","../node_modules/swup/dist/Swup.modern.js","../src/index.ts"],"sourcesContent":["function r(){return r=Object.assign?Object.assign.bind():function(r){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=e[t])}return r},r.apply(this,arguments)}const n=r=>String(r).split(\".\").map(r=>String(parseInt(r||\"0\",10))).concat([\"0\",\"0\"]).slice(0,3).join(\".\");class e{constructor(){this.isSwupPlugin=!0,this.swup=void 0,this.version=void 0,this.requires={},this.handlersToUnregister=[]}mount(){}unmount(){this.handlersToUnregister.forEach(r=>r()),this.handlersToUnregister=[]}_beforeMount(){if(!this.name)throw new Error(\"You must define a name of plugin when creating a class.\")}_afterUnmount(){}_checkRequirements(){return\"object\"!=typeof this.requires||Object.entries(this.requires).forEach(([r,e])=>{if(!function(r,e,t){const s=function(r,n){var e;if(\"swup\"===r)return null!=(e=n.version)?e:\"\";{var t;const e=n.findPlugin(r);return null!=(t=null==e?void 0:e.version)?t:\"\"}}(r,t);return!!s&&((r,e)=>e.every(e=>{const[,t,s]=e.match(/^([\\D]+)?(.*)$/)||[];var o,i;return((r,n)=>{const e={\"\":r=>0===r,\">\":r=>r>0,\">=\":r=>r>=0,\"<\":r=>r<0,\"<=\":r=>r<=0};return(e[n]||e[\"\"])(r)})((i=s,o=n(o=r),i=n(i),o.localeCompare(i,void 0,{numeric:!0})),t||\">=\")}))(s,e)}(r,e=Array.isArray(e)?e:[e],this.swup)){const n=`${r} ${e.join(\", \")}`;throw new Error(`Plugin version mismatch: ${this.name} requires ${n}`)}}),!0}on(r,n,e={}){var t;n=!(t=n).name.startsWith(\"bound \")||t.hasOwnProperty(\"prototype\")?n.bind(this):n;const s=this.swup.hooks.on(r,n,e);return this.handlersToUnregister.push(s),s}once(n,e,t={}){return this.on(n,e,r({},t,{once:!0}))}before(n,e,t={}){return this.on(n,e,r({},t,{before:!0}))}replace(n,e,t={}){return this.on(n,e,r({},t,{replace:!0}))}off(r,n){return this.swup.hooks.off(r,n)}}export{e as default};\n//# sourceMappingURL=index.modern.js.map\n","/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \".concat(i));\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \".concat(j));\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \".concat(j));\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \".concat(i));\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \".concat(i));\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\".concat(escapeString(options.delimiter || \"/#?\"), \"]+?\");\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\".concat(token.pattern, \")$\"), reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not repeat, but got an array\"));\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not be empty\"));\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to be \").concat(typeOfMessage));\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\",\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? \"/#?\" : _e, _f = options.endsWith, endsWith = _f === void 0 ? \"\" : _f;\n    var endsWithRe = \"[\".concat(escapeString(endsWith), \"]|$\");\n    var delimiterRe = \"[\".concat(escapeString(delimiter), \"]\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n                    }\n                    else {\n                        route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n                    }\n                }\n                else {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        route += \"((?:\".concat(token.pattern, \")\").concat(token.modifier, \")\");\n                    }\n                    else {\n                        route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n                    }\n                }\n            }\n            else {\n                route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"\".concat(delimiterRe, \"?\");\n        route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWithRe, \")\");\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n            : endToken === undefined;\n        if (!strict) {\n            route += \"(?:\".concat(delimiterRe, \"(?=\").concat(endsWithRe, \"))?\");\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\".concat(delimiterRe, \"|\").concat(endsWithRe, \")\");\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map","import t from\"delegate-it\";import{match as e}from\"path-to-regexp\";function i(){return i=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var s in i)Object.prototype.hasOwnProperty.call(i,s)&&(t[s]=i[s])}return t},i.apply(this,arguments)}const s=(t,e)=>String(t).toLowerCase().replace(/[\\s/_.]+/g,\"-\").replace(/[^\\w-]+/g,\"\").replace(/--+/g,\"-\").replace(/^-+|-+$/g,\"\")||e||\"\",n=({hash:t}={})=>location.pathname+location.search+(t?location.hash:\"\"),o=(t,e={})=>{const s=i({url:t=t||n({hash:!0}),random:Math.random(),source:\"swup\"},e);history.pushState(s,\"\",t)},r=(t=null,e={})=>{t=t||n({hash:!0});const s=i({},history.state,{url:t,random:Math.random(),source:\"swup\"},e);history.replaceState(s,\"\",t)},a=(e,s,n,o)=>{const r=new AbortController;return o=i({},o,{signal:r.signal}),t(e,s,n,o),{destroy:()=>r.abort()}};class l extends URL{constructor(t,e=document.baseURI){super(t.toString(),e)}get url(){return this.pathname+this.search}static fromElement(t){const e=t.getAttribute(\"href\")||t.getAttribute(\"xlink:href\")||\"\";return new l(e)}static fromUrl(t){return new l(t)}}const h=(t,i)=>{try{return e(t,i)}catch(e){throw new Error(`[swup] Error parsing path \"${t}\":\\n${e}`)}};class c{constructor(t){this.swup=void 0,this.pages=new Map,this.swup=t}get size(){return this.pages.size}get all(){return this.pages}has(t){return this.pages.has(this.resolve(t))}get(t){return this.pages.get(this.resolve(t))}set(t,e){e=i({},e,{url:t=this.resolve(t)}),this.pages.set(t,e),this.swup.hooks.callSync(\"cache:set\",{page:e})}update(t,e){t=this.resolve(t),e=i({},this.get(t),e,{url:t}),this.pages.set(t,e)}delete(t){this.pages.delete(this.resolve(t))}clear(){this.pages.clear(),this.swup.hooks.callSync(\"cache:clear\")}prune(t){this.pages.forEach((e,i)=>{t(i,e)&&this.delete(i)})}resolve(t){const{url:e}=l.fromUrl(t);return this.swup.resolveUrl(e)}}const u=(t,e=document)=>e.querySelector(t),p=(t,e=document)=>Array.from(e.querySelectorAll(t)),d=()=>new Promise(t=>{requestAnimationFrame(()=>{requestAnimationFrame(()=>{t()})})});function m(t){return!!t&&(\"object\"==typeof t||\"function\"==typeof t)&&\"function\"==typeof t.then}function g(t,e=[]){return new Promise((i,s)=>{const n=t(...e);m(n)?n.then(i,s):i(n)})}function f(t){var e;return null==(e=t=t||document.body)?void 0:e.offsetHeight}const w=t=>window.CSS&&window.CSS.escape?CSS.escape(t):t,v=t=>1e3*Number(t.slice(0,-1).replace(\",\",\".\"));class y{constructor(t){this.swup=void 0,this.swupClasses=[\"to-\",\"is-changing\",\"is-rendering\",\"is-popstate\",\"is-animating\"],this.swup=t}get selectors(){const{scope:t}=this.swup.visit.animation;return\"containers\"===t?this.swup.visit.containers:\"html\"===t?[\"html\"]:Array.isArray(t)?t:[]}get selector(){return this.selectors.join(\",\")}get targets(){return this.selector.trim()?p(this.selector):[]}add(...t){this.targets.forEach(e=>e.classList.add(...t))}remove(...t){this.targets.forEach(e=>e.classList.remove(...t))}clear(){this.targets.forEach(t=>{const e=t.className.split(\" \").filter(t=>this.isSwupClass(t));t.classList.remove(...e)})}isSwupClass(t){return this.swupClasses.some(e=>t.startsWith(e))}}function k({to:t,from:e=this.currentPageUrl,hash:i,animate:s=!0,animation:n,el:o,event:r,action:a=\"push\",resetScroll:l=!0}){return{from:{url:e},to:{url:t},containers:this.options.containers,animation:{animate:s,wait:!1,name:n,scope:this.options.animationScope,selector:this.options.animationSelector},trigger:{el:o,event:r},history:{action:a,popstate:!1,direction:void 0},scroll:{reset:l,target:i}}}class S{constructor(t){this.swup=void 0,this.registry=new Map,this.hooks=[\"animation:out:start\",\"animation:out:await\",\"animation:out:end\",\"animation:in:start\",\"animation:in:await\",\"animation:in:end\",\"animation:skip\",\"cache:clear\",\"cache:set\",\"content:replace\",\"content:scroll\",\"enable\",\"disable\",\"fetch:request\",\"fetch:error\",\"history:popstate\",\"link:click\",\"link:self\",\"link:anchor\",\"link:newtab\",\"page:load\",\"page:view\",\"scroll:top\",\"scroll:anchor\",\"visit:start\",\"visit:end\"],this.swup=t,this.init()}init(){this.hooks.forEach(t=>this.create(t))}create(t){this.registry.has(t)||this.registry.set(t,new Map)}exists(t){return this.registry.has(t)}get(t){const e=this.registry.get(t);if(e)return e;console.error(`Unknown hook '${t}'`)}clear(){this.registry.forEach(t=>t.clear())}on(t,e,s={}){const n=this.get(t);if(!n)return console.warn(`Hook '${t}' not found.`),()=>{};const o=i({},s,{id:n.size+1,hook:t,handler:e});return n.set(e,o),()=>this.off(t,e)}before(t,e,s={}){return this.on(t,e,i({},s,{before:!0}))}replace(t,e,s={}){return this.on(t,e,i({},s,{replace:!0}))}once(t,e,s={}){return this.on(t,e,i({},s,{once:!0}))}off(t,e){const i=this.get(t);i&&e?i.delete(e)||console.warn(`Handler for hook '${t}' not found.`):i&&i.clear()}async call(t,e,i){const{before:s,handler:n,after:o}=this.getHandlers(t,i);await this.run(s,e);const[r]=await this.run(n,e);return await this.run(o,e),this.dispatchDomEvent(t,e),r}callSync(t,e,i){const{before:s,handler:n,after:o}=this.getHandlers(t,i);this.runSync(s,e);const[r]=this.runSync(n,e);return this.runSync(o,e),this.dispatchDomEvent(t,e),r}async run(t,e){const i=[];for(const{hook:s,handler:n,defaultHandler:o,once:r}of t){const t=await g(n,[this.swup.visit,e,o]);i.push(t),r&&this.off(s,n)}return i}runSync(t,e){const i=[];for(const{hook:s,handler:n,defaultHandler:o,once:r}of t){const t=n(this.swup.visit,e,o);i.push(t),m(t)&&console.warn(`Promise returned from handler for synchronous hook '${s}'.Swup will not wait for it to resolve.`),r&&this.off(s,n)}return i}getHandlers(t,e){const i=this.get(t);if(!i)return{found:!1,before:[],handler:[],after:[],replaced:!1};const s=this.sortRegistrations,n=Array.from(i.values()),o=n.filter(({before:t,replace:e})=>t&&!e).sort(s),r=n.filter(({replace:t})=>t).sort(s),a=n.filter(({before:t,replace:e})=>!t&&!e).sort(s),l=r.length>0;let h=[];if(e&&(h=[{id:0,hook:t,handler:e}],l)){const i=r.length-1,s=t=>{const i=r[t-1];return i?(e,n)=>i.handler(e,n,s(t-1)):e};h=[{id:0,hook:t,handler:r[i].handler,defaultHandler:s(i)}]}return{found:!0,before:o,handler:h,after:a,replaced:l}}sortRegistrations(t,e){var i,s;return(null!=(i=t.priority)?i:0)-(null!=(s=e.priority)?s:0)||t.id-e.id||0}dispatchDomEvent(t,e){document.dispatchEvent(new CustomEvent(`swup:${t}`,{detail:{hook:t,args:e,visit:this.swup.visit}}))}}const b=t=>{if(t&&\"#\"===t.charAt(0)&&(t=t.substring(1)),!t)return null;const e=decodeURIComponent(t);let i=document.getElementById(t)||document.getElementById(e)||u(`a[name='${w(t)}']`)||u(`a[name='${w(e)}']`);return i||\"top\"!==t||(i=document.body),i},U=\"transition\",P=\"animation\";async function E({elements:t,selector:e}){if(!1===e&&!t)return;let i=[];if(t)i=Array.from(t);else if(e&&(i=p(e,document.body),!i.length))return void console.warn(`[swup] No elements found matching animationSelector \\`${e}\\``);const s=i.map(t=>function(t){const{type:e,timeout:i,propCount:s}=function(t,e){const i=window.getComputedStyle(t),s=C(i,`${U}Delay`),n=C(i,`${U}Duration`),o=$(s,n),r=C(i,`${P}Delay`),a=C(i,`${P}Duration`),l=$(r,a);let h=null,c=0,u=0;return c=Math.max(o,l),h=c>0?o>l?U:P:null,u=h?h===U?n.length:a.length:0,{type:h,timeout:c,propCount:u}}(t);return!(!e||!i)&&new Promise(n=>{const o=`${e}end`,r=performance.now();let a=0;const l=()=>{t.removeEventListener(o,h),n()},h=e=>{if(e.target===t){if(!function(t){return[`${U}end`,`${P}end`].includes(t.type)}(e))throw new Error(\"Not a transition or animation event.\");(performance.now()-r)/1e3<e.elapsedTime||++a>=s&&l()}};setTimeout(()=>{a<s&&l()},i+1),t.addEventListener(o,h)})}(t));s.filter(Boolean).length>0?await Promise.all(s):e&&console.warn(`[swup] No CSS animation duration defined on elements matching \\`${e}\\``)}function C(t,e){return(t[e]||\"\").split(\", \")}function $(t,e){for(;t.length<e.length;)t=t.concat(t);return Math.max(...e.map((e,i)=>v(e)+v(t[i])))}function x(t,e={},s={}){if(this.shouldIgnoreVisit(t,{el:s.el,event:s.event}))return void(window.location.href=t);const{url:n,hash:o}=l.fromUrl(t);this.visit=this.createVisit(i({},s,{to:n,hash:o})),this.performNavigation(n,e)}async function A(t,e={}){if(\"string\"!=typeof t)throw new Error(\"swup.navigate() requires a URL parameter\");const{el:i}=this.visit.trigger;this.visit.to.url=l.fromUrl(t).url,e.referrer=e.referrer||this.currentPageUrl,!1===e.animate&&(this.visit.animation.animate=!1),this.visit.animation.animate||this.classes.clear();const s=e.history||(null==i?void 0:i.getAttribute(\"data-swup-history\"))||void 0;s&&[\"push\",\"replace\"].includes(s)&&(this.visit.history.action=s);const a=e.animation||(null==i?void 0:i.getAttribute(\"data-swup-animation\"))||void 0;a&&(this.visit.animation.name=a);try{await this.hooks.call(\"visit:start\");const i=this.hooks.call(\"page:load\",{options:e},async(t,e)=>{const i=this.cache.get(t.to.url);return e.page=i||await this.fetchPage(t.to.url,e.options),e.cache=!!i,e.page});if(!this.visit.history.popstate){const e=t+(this.visit.scroll.target||\"\");\"replace\"===this.visit.history.action?r(e):o(e,{index:this.currentHistoryIndex+1})}if(this.currentPageUrl=n(),this.visit.animation.wait){const{html:t}=await i;this.visit.to.html=t}const s=this.animatePageOut(),[a]=await Promise.all([i,s]);await this.renderPage(this.visit.to.url,a),await this.animatePageIn(),await this.hooks.call(\"visit:end\",void 0,()=>this.classes.clear())}catch(t){if(!t)return;console.error(t),this.options.skipPopStateHandling=()=>(window.location.href=this.visit.to.url,!0),window.history.go(-1)}}class H extends Error{constructor(t,e){super(t),this.url=void 0,this.status=void 0,this.name=\"FetchError\",this.url=e.url,this.status=e.status}}async function q(t,e={}){t=l.fromUrl(t).url;const s=i({},this.options.requestHeaders,e.headers);e=i({},e,{headers:s});const n=await this.hooks.call(\"fetch:request\",{url:t,options:e},(t,{url:e,options:i})=>fetch(e,i)),{status:o,url:r}=n,a=await n.text();if(500===o)throw this.hooks.call(\"fetch:error\",{status:o,response:n,url:r}),new H(`Server error: ${r}`,{status:o,url:r});if(!a)throw new H(`Empty response: ${r}`,{status:o,url:r});const{url:h}=l.fromUrl(r),c={url:h,html:a};return t===h&&this.cache.set(c.url,c),c}const L=async function(){this.visit.animation.animate?(await this.hooks.call(\"animation:out:start\",void 0,t=>{this.classes.add(\"is-changing\",\"is-leaving\",\"is-animating\"),t.history.popstate&&this.classes.add(\"is-popstate\"),t.animation.name&&this.classes.add(`to-${s(t.animation.name)}`)}),await this.hooks.call(\"animation:out:await\",{skip:!1},async(t,{skip:e})=>{e||await this.awaitAnimations({selector:t.animation.selector})}),await this.hooks.call(\"animation:out:end\")):await this.hooks.call(\"animation:skip\")},R=function({html:t},{containers:e}=this.options){var i;const s=(new DOMParser).parseFromString(t,\"text/html\"),n=(null==(i=s.querySelector(\"title\"))?void 0:i.innerText)||\"\";return document.title=n,e.map(t=>{const e=document.querySelector(t),i=s.querySelector(t);return e&&i?(e.replaceWith(i),!0):(e||console.warn(`[swup] Container missing in current document: ${t}`),i||console.warn(`[swup] Container missing in incoming document: ${t}`),!1)}).filter(Boolean).length===e.length},I=function(){const t={behavior:\"auto\"},{target:e,reset:s}=this.visit.scroll;let n=!1;return e&&(n=this.hooks.callSync(\"scroll:anchor\",{hash:e,options:t},(t,{hash:e,options:i})=>{const s=this.getAnchorElement(e||\"\");return s&&s.scrollIntoView(i),!!s})),s&&!n&&(n=this.hooks.callSync(\"scroll:top\",{options:t},(t,{options:e})=>(window.scrollTo(i({top:0,left:0},e)),!0))),n},N=async function(){if(!this.visit.animation.animate)return;const t=this.hooks.call(\"animation:in:await\",{skip:!1},async(t,{skip:e})=>{e||await this.awaitAnimations({selector:t.animation.selector})});await d(),await this.hooks.call(\"animation:in:start\",void 0,()=>{this.classes.remove(\"is-animating\")}),await t,await this.hooks.call(\"animation:in:end\")},D=async function(t,e){const{url:i,html:o}=e;this.classes.remove(\"is-leaving\"),this.isSameResolvedUrl(n(),t)&&(this.isSameResolvedUrl(n(),i)||(r(i),this.currentPageUrl=n(),this.visit.to.url=this.currentPageUrl),this.visit.animation.animate&&this.classes.add(\"is-rendering\"),this.visit.to.html=o,await this.hooks.call(\"content:replace\",{page:e},(t,{page:e})=>{if(!this.replaceContent(e,{containers:t.containers}))throw new Error(\"[swup] Container mismatch, aborting\");t.animation.animate&&(this.classes.add(\"is-animating\",\"is-changing\",\"is-rendering\"),t.animation.name&&this.classes.add(`to-${s(t.animation.name)}`))}),await this.hooks.call(\"content:scroll\",void 0,()=>this.scrollToContent()),await this.hooks.call(\"page:view\",{url:this.currentPageUrl,title:document.title}),this.options.cache||this.cache.clear())},V=function(t){var e;if(null==(e=t)?void 0:e.isSwupPlugin){if(t.swup=this,!t._checkRequirements||t._checkRequirements())return t._beforeMount&&t._beforeMount(),t.mount(),this.plugins.push(t),this.plugins}else console.error(\"Not a swup plugin instance\",t)};function M(t){const e=this.findPlugin(t);if(e)return e.unmount(),e._afterUnmount&&e._afterUnmount(),this.plugins=this.plugins.filter(t=>t!==e),this.plugins;console.error(\"No such plugin\",e)}function O(t){return this.plugins.find(e=>e===t||e.name===t||e.name===`Swup${t}`)}function T(t){if(\"function\"!=typeof this.options.resolveUrl)return console.warn(\"[swup] options.resolveUrl expects a callback function.\"),t;const e=this.options.resolveUrl(t);return e&&\"string\"==typeof e?e.startsWith(\"//\")||e.startsWith(\"http\")?(console.warn(\"[swup] options.resolveUrl needs to return a relative url\"),t):e:(console.warn(\"[swup] options.resolveUrl needs to return a url\"),t)}function W(t,e){return this.resolveUrl(t)===this.resolveUrl(e)}const _={animateHistoryBrowsing:!1,animationSelector:'[class*=\"transition-\"]',animationScope:\"html\",cache:!0,containers:[\"#swup\"],ignoreVisit:(t,{el:e}={})=>!(null==e||!e.closest(\"[data-no-swup]\")),linkSelector:\"a[href]\",plugins:[],resolveUrl:t=>t,requestHeaders:{\"X-Requested-With\":\"swup\",Accept:\"text/html, application/xhtml+xml\"},skipPopStateHandling:t=>{var e;return\"swup\"!==(null==(e=t.state)?void 0:e.source)}};class B{constructor(t={}){this.version=\"4.0.0\",this.options=void 0,this.defaults=_,this.plugins=[],this.visit=void 0,this.cache=void 0,this.hooks=void 0,this.classes=void 0,this.currentPageUrl=n(),this.currentHistoryIndex=1,this.clickDelegate=void 0,this.use=V,this.unuse=M,this.findPlugin=O,this.log=()=>{},this.navigate=x,this.performNavigation=A,this.createVisit=k,this.delegateEvent=a,this.fetchPage=q,this.awaitAnimations=E,this.renderPage=D,this.replaceContent=R,this.animatePageIn=N,this.animatePageOut=L,this.scrollToContent=I,this.getAnchorElement=b,this.getCurrentUrl=n,this.resolveUrl=T,this.isSameResolvedUrl=W,this.options=i({},this.defaults,t),this.handleLinkClick=this.handleLinkClick.bind(this),this.handlePopState=this.handlePopState.bind(this),this.cache=new c(this),this.classes=new y(this),this.hooks=new S(this),this.visit=this.createVisit({to:void 0}),this.checkRequirements()&&this.enable()}checkRequirements(){return\"undefined\"!=typeof Promise||(console.warn(\"Promise is not supported\"),!1)}async enable(){const{linkSelector:t}=this.options;this.clickDelegate=this.delegateEvent(t,\"click\",this.handleLinkClick),window.addEventListener(\"popstate\",this.handlePopState),this.options.plugins.forEach(t=>this.use(t)),r(null,{index:1}),await d(),await this.hooks.call(\"enable\",void 0,()=>{document.documentElement.classList.add(\"swup-enabled\")})}async destroy(){this.clickDelegate.destroy(),window.removeEventListener(\"popstate\",this.handlePopState),this.cache.clear(),this.options.plugins.forEach(t=>this.unuse(t)),await this.hooks.call(\"disable\",void 0,()=>{document.documentElement.classList.remove(\"swup-enabled\")}),this.hooks.clear()}shouldIgnoreVisit(t,{el:e,event:i}={}){const{origin:s,url:n,hash:o}=l.fromUrl(t);return s!==window.location.origin||!(!e||!this.triggerWillOpenNewWindow(e))||!!this.options.ignoreVisit(n+o,{el:e,event:i})}handleLinkClick(t){const e=t.delegateTarget,{href:i,url:s,hash:n}=l.fromElement(e);this.shouldIgnoreVisit(i,{el:e,event:t})||(this.visit=this.createVisit({to:s,hash:n,el:e,event:t}),t.metaKey||t.ctrlKey||t.shiftKey||t.altKey?this.hooks.call(\"link:newtab\",{href:i}):0===t.button&&this.hooks.callSync(\"link:click\",{el:e,event:t},()=>{var e;const i=null!=(e=this.visit.from.url)?e:\"\";t.preventDefault(),s&&s!==i?this.isSameResolvedUrl(s,i)||this.performNavigation(s):n?this.hooks.callSync(\"link:anchor\",{hash:n},()=>{r(s+n),this.scrollToContent()}):this.hooks.callSync(\"link:self\",void 0,()=>{this.scrollToContent()})}))}handlePopState(t){var e,i,s;const o=null!=(e=null==(i=t.state)?void 0:i.url)?e:location.href;if(this.options.skipPopStateHandling(t))return;if(this.isSameResolvedUrl(n(),this.currentPageUrl))return;if(this.shouldIgnoreVisit(o,{event:t}))return;const{url:r,hash:a}=l.fromUrl(o);this.visit=this.createVisit({to:r,hash:a,event:t,animate:this.options.animateHistoryBrowsing,resetScroll:this.options.animateHistoryBrowsing}),this.visit.history.popstate=!0;const h=Number(null==(s=t.state)?void 0:s.index);h&&(this.visit.history.direction=h-this.currentHistoryIndex>0?\"forwards\":\"backwards\"),this.hooks.callSync(\"history:popstate\",{event:t},()=>{this.performNavigation(r)})}triggerWillOpenNewWindow(t){return!!t.matches('[download], [target=\"_blank\"]')}}export{l as Location,s as classify,o as createHistoryRecord,B as default,a as delegateEvent,w as escapeCssIdentifier,f as forceReflow,n as getCurrentUrl,m as isPromise,h as matchPath,d as nextTick,u as query,p as queryAll,g as runAsPromise,v as toMs,r as updateHistoryRecord};\n//# sourceMappingURL=Swup.modern.js.map\n","import Plugin from '@swup/plugin';\nimport { classify, getCurrentUrl, matchPath, updateHistoryRecord } from 'swup';\nimport type { Visit } from 'swup';\n\ndeclare module 'swup' {\n\texport interface VisitFrom {\n\t\t/** Identified route name */\n\t\troute?: string;\n\t}\n\texport interface VisitTo {\n\t\t/** Identified route name */\n\t\troute?: string;\n\t}\n}\n\ntype Route = {\n\t/** The name of the route. */\n\tname: string;\n\t/** The path pattern to match the URL against. */\n\tpath: string;\n};\n\ntype CompiledRoute = Route & {\n\t/** Match function to check if the pattern matches a given URL */\n\tmatches: MatchFunction;\n};\n\ntype MatchOptions = Parameters<typeof matchPath>[1];\ntype MatchFunction = ReturnType<typeof matchPath>;\n\ntype Options = {\n\t/** Array of patterns for identifying named routes. */\n\troutes: Route[];\n\t/** Default route name if no match was found. */\n\tunknownRoute: string;\n\t/** Options for matching paths. Directly passed into `path-to-regexp`. */\n\tmatchOptions: MatchOptions;\n\t/** Add classnames for raw URLs. */\n\tpaths: boolean;\n};\n\nexport default class SwupRouteNamePlugin extends Plugin {\n\tname = 'SwupRouteNamePlugin';\n\n\trequires = { swup: '>=4' };\n\n\tdefaults: Options = {\n\t\troutes: [],\n\t\tunknownRoute: 'unknown',\n\t\tmatchOptions: {},\n\t\tpaths: false\n\t};\n\toptions: Options;\n\n\troutes: CompiledRoute[];\n\n\tconstructor(options: Partial<Options> = {}) {\n\t\tsuper();\n\t\tthis.options = { ...this.defaults, ...options };\n\t\tthis.routes = this.compileRoutePatterns();\n\t}\n\n\tmount() {\n\t\t// Save route to current history record\n\t\tthis.swup.visit.to.route = this.getRouteName(getCurrentUrl());\n\t\tthis.updateHistory(this.swup.visit);\n\n\t\tthis.before('visit:start', this.addRouteKey);\n\t\tthis.on('animation:out:start', this.addPathClasses);\n\t\tthis.on('animation:out:start', this.addRouteClasses);\n\t\tthis.on('content:replace', this.updateHistory);\n\t\tthis.on('animation:in:end', this.removeClasses);\n\t}\n\n\t// Compile route patterns to match functions and valid classnames\n\tcompileRoutePatterns() {\n\t\treturn this.options.routes.map((route) => {\n\t\t\tconst name = this.sanitizeRouteName(route.name);\n\t\t\tconst matches = matchPath(route.path, this.options.matchOptions);\n\t\t\treturn { ...route, name, matches };\n\t\t});\n\t}\n\n\tsanitizeRouteName(name: string): string {\n\t\treturn name.replace(/[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~\\s]/g, '');\n\t}\n\n\t// Get route name for any path\n\tgetRouteName(path: string): string | undefined {\n\t\tconst { name } = this.routes.find((route) => route.matches(path)) || {};\n\t\treturn name || undefined;\n\t}\n\n\t// Get path name for any path\n\tgetPathName(path: string) {\n\t\treturn classify(path) || 'homepage';\n\t}\n\n\t// Add a `route` key to the visit object's `from` and `to` properties\n\taddRouteKey(visit: Visit) {\n\t\tif (!this.options.routes.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tvisit.from.route = this.getRouteName(visit.from.url);\n\t\tvisit.to.route = this.getRouteName(visit.to.url!);\n\t\tconst unknown = this.options.unknownRoute;\n\n\t\tthis.swup.log(\n\t\t\t`Route: '${visit.from.route || unknown || '(unknown)'}'` +\n\t\t\t\t` to '${visit.to.route || unknown || '(unknown)'}'`\n\t\t);\n\t}\n\n\t// Add `from-route-*` and `to-route-*` classnames to html tag\n\taddRouteClasses(visit: Visit) {\n\t\tif (!this.options.routes.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst from = visit.from.route;\n\t\tconst to = visit.to.route;\n\t\tconst unknown = this.options.unknownRoute;\n\n\t\tif (from || unknown) {\n\t\t\tdocument.documentElement.classList.add(`from-route-${from || unknown}`);\n\t\t}\n\t\tif (to || unknown) {\n\t\t\tdocument.documentElement.classList.add(`to-route-${to || unknown}`);\n\t\t}\n\t\tif (from && from === to) {\n\t\t\tdocument.documentElement.classList.add('to-same-route');\n\t\t}\n\t}\n\n\t// Add `from-*` and `to-*` classnames for slugified path\n\taddPathClasses(visit: Visit) {\n\t\tif (!this.options.paths) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst from = this.getPathName(visit.from.url);\n\t\tconst to = this.getPathName(visit.to.url!);\n\n\t\tdocument.documentElement.classList.add(`from-${from}`);\n\t\tdocument.documentElement.classList.add(`to-${to}`);\n\t}\n\n\t// Remove `from-*` and `from-route-*` classnames from html tag\n\t// Note: swup removes `to-*` classnames on its own already\n\tremoveClasses() {\n\t\tconst htmlClasses = document.documentElement.className.split(' ');\n\t\tconst removeClasses = htmlClasses.filter((classItem) => classItem.startsWith('from-'));\n\t\tdocument.documentElement.classList.remove(...removeClasses);\n\t}\n\n\tupdateHistory(visit: Visit) {\n\t\tupdateHistoryRecord(undefined, { route: visit.to.route });\n\t}\n}\n"],"names":["normalizeVersion","version","String","split","map","segment","parseInt","concat","slice","join","installed","requirements","every","required","comparator","match","a","b","comparisonResult","comparators","r","localeCompare","numeric","str","options","keys","re","_a","decode","x","pathname","m","exec","path","index","params","Object","create","i","undefined","key","name","modifier","prefix","suffix","value","length","regexpToFunction","pathToRegexp","escapeString","replace","flags","sensitive","RegExp","groupsRegex","execResult","source","push","pattern","regexpToRegexp","Array","isArray","paths","parts","arrayToRegexp","tokens","strict","_b","start","_c","end","_d","encode","_e","delimiter","_f","endsWith","endsWithRe","delimiterRe","route","tokens_1","_i","token","mod","endToken","isEndDelimited","indexOf","tokensToRegexp","char","type","count","j","TypeError","code","charCodeAt","lexer","prefixes","defaultPattern","result","tryConsume","mustConsume","nextType","consumeText","name_1","pattern_1","parse","stringToRegexp","constructor","super","this","requires","swup","defaults","routes","unknownRoute","matchOptions","compileRoutePatterns","mount","visit","to","getRouteName","getCurrentUrl","updateHistory","before","addRouteKey","on","addPathClasses","addRouteClasses","removeClasses","sanitizeRouteName","matches","matchPath","find","getPathName","toLowerCase","from","url","log","unknown","document","documentElement","classList","add","className","filter","classItem","startsWith","remove","updateHistoryRecord"],"mappings":"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"}