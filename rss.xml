<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>阿龙种树</title><description>全栈放</description><link>https://fuwari.vercel.app/</link><language>zh_CN</language><item><title>客户端到服务端边界</title><link>https://fuwari.vercel.app/posts/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BE%B9%E7%95%8C/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BE%B9%E7%95%8C/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BE%B9%E7%95%8C/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BE%B9%E7%95%8C/</guid><description>从一个url链接点击下去，到到达服务端边界之间的所有事情</description><pubDate>Tue, 29 Oct 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;前缀知识, TCP/IP协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;DNS协议&lt;/h2&gt;
&lt;p&gt;本文将探讨互联网最常见的http请求的完整流程,首先我们了解到早于 http3.0 之前, 协议使用的TCP的网络协议,可以根据 源ip端口+目标IP端口+协议的方式 进行网络通信. 考虑到ip和端口都是数字不便记忆,域名便成为了主要的操作参数. 于是我们可以建立一个类似电话本的方式,映射域名和ip+端口的方式.
&lt;img src=&quot;./file-20241026153513873.png&quot; alt=&quot;域名&quot; /&gt;
对于一个 linux 客户的机器, /etc/hosts 文件就是这个电话本&lt;/p&gt;
&lt;p&gt;但是从实际考虑, 这个表的内容完全有可能更新,频繁的更改本地这个文件是不现实的. 而且考虑到我们的网络安全情况,这个文件在系统中有很高的权限,不会允许普通用户进行改动,所以我们的实际用到的映射信息在其他的文件中 可以通过命令查看, 我们的浏览器一般也会单独缓存一份.&lt;/p&gt;
&lt;p&gt;然而本地存储全球所有的域名表这并不现实, 即使使用一个完整的机器存储压力也是很大的, 而且并不适用于跨设备共享, 所以会有组织进行域名服务器的架设,而我们只需要设置系统的域名到达这个电话本的位置进行查询即可.&lt;/p&gt;
&lt;p&gt;对于域名服务器而言,需要应对所有网络访问设备的访问也难以承载, 因此会引入一种负载均衡的思想,将用户的请求按照特征进行分流.
例如我们要访问 &lt;code&gt;pan.baidu.com&lt;/code&gt;的域名;
那么我们将访问 DNS根服务器 根服务器看到我是 &lt;code&gt;.com&lt;/code&gt; 结尾,给到我顶级DNS服务器的地址;
我们访问&lt;code&gt;.com&lt;/code&gt;对应的顶级域名服务器, 可以找到是 &lt;code&gt;baidu.com&lt;/code&gt; ,给到我权威DNS服务器的地址;
我们访问&lt;code&gt;baidu.com&lt;/code&gt;的权威DNS服务器, 权威DNS服务器,理解到这是 &lt;code&gt;pan.baidu.com&lt;/code&gt;给到我们具体的业务服务器的IP+端口(这里指的是业务侧负载均衡层的地址,属于是业务对外暴露的但不是实际处理业务的)&lt;/p&gt;
&lt;p&gt;那么经过一套复杂的情况我们访问到了, 我们考虑到这个过程的复杂性, 网络运行商一般也会提供一层的代理服务, 对于这一套的寻路信息进行暂存.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./file-20241026155320328.png&quot; alt=&quot;dns协议&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从这个图片中,抛开客户的软件, 其他内容共同组成 DNS服务.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;HTTP协议&lt;/h2&gt;
&lt;p&gt;如此,我们形成了网络层面的业务通路. 前面我们提到,早期包括目前还在使用的http协议大多使用TCP 完成实现.&lt;/p&gt;
&lt;p&gt;在TCP的三次握手建立面向连接的通信后;
通过发送特殊构成的 http 请求字符结构 来完成客户端服务申请;
而对于服务器端来说, 队协议栈进行逆向的操作;
根据 请求头 实际的业务请求进行处理返回;
用户侧的浏览器等工具会将内容按照预设的格式展示出来;
然后TCP的四次挥手结束,双方断开连接&lt;/p&gt;
&lt;p&gt;下图是关于 http 请求一个基本的格式
&lt;img src=&quot;./file-20241026160130555.png&quot; alt=&quot;http请求&quot; /&gt;
而服务端的回复 往往也有相对固定的结构
&lt;img src=&quot;./file-20241026160320323.png&quot; alt=&quot;http响应&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;中间人攻击&lt;/h2&gt;
&lt;p&gt;这里有一个隐患,关于 http 所有网络数据的传递是明文的,这意味着在多个网络路由跳转的过程中, 中间人都可以对内容进行查阅和篡改, 形成了非常不安全的情况.
所以加密行为成了不得不引入的方案了, 这很经典 加解密的行为出现得比计算机还要早.&lt;/p&gt;
&lt;h3&gt;对称加密&lt;/h3&gt;
&lt;p&gt;假设 A B两个人都用同一个保险箱传递内容, 使用着相同的钥匙,那么中间的恶意者无法打开保险箱,无法查看和篡改,所以数据是安全的.
但是钥匙我该怎么给到另一个人呢, 如果传递钥匙的时候就已经被获取复制,那么 相当于中间人还是可以查看和篡改,这很糟糕.
常用的对称加密有 AES DES 等&lt;/p&gt;
&lt;h3&gt;非对称加密&lt;/h3&gt;
&lt;p&gt;同样是上面的场景, 假设A和B可以不同的钥匙, A上锁后只能交给B来解锁, B加密后只能交给A来解锁.
我们回到上面的场景,假设B有两把钥匙, 将公钥下发给客户A,中间人也偷偷拿到了公钥,客户A通过公钥加密了, 那么数据只能使用B手上的私钥进行解密了,那么数据包回传的时候,中间人再想使用前面偷到的公钥解密,是做不到的.所以数据只能在服务器端通过私钥解密.&lt;/p&gt;
&lt;p&gt;常用的非对称加密有RSA 等&lt;/p&gt;
&lt;p&gt;当我们以为非对称加密是无敌的时候, 中间人的策略进行了升级, 我试图在服务端发出公钥的时候 就进行篡改替换成了自己的公钥, 继续发给客户,客户并不知情进行加密,发送了请求,由于密钥是中间人给的,那么中间人可以有自己私钥解密,然后还原成原本的服务端公钥加密版本.&lt;/p&gt;
&lt;p&gt;在这个场景下, 客户和服务端都不知道自己的数据是否被查阅和修改.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;ca 证书机制&lt;/h2&gt;
&lt;p&gt;上一个场景, 我们即使使用了非对称加密也无法保证信息传递的安全性,似乎只有通过网络之外的其他渠道进行密钥的传递, 这当然是不现实的. ca机构应运而生.&lt;/p&gt;
&lt;p&gt;首先,服务端会在业务上线之前 将自己的域名,公钥等信息发送给ca机构
ca机构审核后,使用公钥将内容加密给回服务端; --- 这里发送的就是证书
再将ca私钥发给客户端;&lt;/p&gt;
&lt;p&gt;上线后的业务场景
服务端先将加密后的证书发送给客户;
客户拥有ca机构发送的私钥,因此能够解析;
如果这个时候中间人获取到包,因为不具备ca的私钥所以数据无法操作
客户根据证书内部的细节,进行后续与服务端的加解密&lt;/p&gt;
&lt;p&gt;这里 关于证书的内容 是对服务端发送内容进行一定的哈希操作 然后对哈希进行加密 因此会保留一部分明文细节.&lt;/p&gt;
&lt;p&gt;这里ca机构和服务端 可能使用丰富的方式来降低证书生成过程的安全问题;
而客户端普通用户明明没有跟ca机构打过交道,为何会有密钥呢? 这个一般是操作系统自带或者浏览器自带&lt;/p&gt;
&lt;p&gt;由于服务业务的庞杂, 跟DNS一样, ca机构一般也是用类似的分层机构的情况;
那么在这个机构中 我们又该如何避免 ca机构是有问题的呢? 这里引入了一个新的概念 透明透明机制
就是所有ca发放证书的时候,需要往日志服务器发送数据,日志的可读权限是共享的,由于ca机构一般也是盈利机构,因此相对的管控下可以保证相对的安全.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非对称加密对比对称加密,从算法复杂度上考虑,更加费时,文件也更大;
所以日常加密的过程,不会使用非对称加密进行通信,而是用来传递对称加密的密钥,进行日常通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;DH密钥交换&lt;/h2&gt;
&lt;p&gt;对于上面提到的密钥交换的场景还有一种数学上的实现,能够简化优化这个过程,那就是DH密钥算法&lt;/p&gt;
&lt;p&gt;首先基于数学的一个概念&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a^x mod p = y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;知道x 计算这个y非常容易,但是知道y 计算x非常困难&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Alice                         Bob
  |                            |
  |------ 公共参数 p,g -------&amp;gt;|   (p是大素数,g是p的原根)
  |                            |
  |--- g^a mod p (A值) ------&amp;gt;|    (a是Alice的私钥)
  |&amp;lt;---- g^b mod p (B值) -----|    (b是Bob的私钥)
  |                            |
计算: B^a mod p          计算: A^b mod p
  =  (g^b)^a mod p            = (g^a)^b mod p
  =  g^(ab) mod p             = g^(ab) mod p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这很抽象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;假设:
p = 23 (素数)
g = 5 (原根)

Alice选择私钥 a = 6
Bob选择私钥 b = 15

Alice计算并发送: A = 5^6 mod 23 = 8
Bob计算并发送: B = 5^15 mod 23 = 19

最终共享密钥:
Alice: 19^6 mod 23 = 2
Bob: 8^15 mod 23 = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者我们构建一个更加通俗的场景&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A B 都搞到了3个杯子&lt;/li&gt;
&lt;li&gt;A这边有两杯数量一致的绿豆 以及一杯黑豆&lt;/li&gt;
&lt;li&gt;B这边有两倍数量一直的红豆(与绿豆数量不同) 以及一杯黑豆(数量是一致的)&lt;/li&gt;
&lt;li&gt;假设为 1,2,3号杯子&lt;/li&gt;
&lt;li&gt;A,B同时操作 将1号杯子的豆子加入3号(黑豆)杯子中&lt;/li&gt;
&lt;li&gt;交换杯子, 将2号杯子倒入3号杯子&lt;/li&gt;
&lt;li&gt;此时 两方得到了一样配比的两个有豆子杯子&lt;/li&gt;
&lt;li&gt;从而得到相同的密钥&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从安全的角度考虑
中间人能看到如下数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;素数p&lt;/li&gt;
&lt;li&gt;原根g&lt;/li&gt;
&lt;li&gt;A发出的g^a mod p&lt;/li&gt;
&lt;li&gt;B发出的g^b mod p&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;无法推算出 双方任何一方的私钥 和最终共同的完整私钥 g^ab /mod p
这里需要够大的素数p 以及定期更换密钥 基本满足安全性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类似还有基于椭圆曲线的 ECDH 密钥交换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般还会双方还会各自生成一个随机数作为因子
交换双方的随机数,双方都有两个,进行密钥的二次加密&lt;/p&gt;
&lt;p&gt;此时 中间人虽然无法对数据进行查阅和修改,但是可以将原本的数据反向传递, A发出我需要一个蛋糕,中间人将数据再次发送给A或者多次发送给B都会造成无法预测的业务混乱.&lt;/p&gt;
&lt;p&gt;因此 一般会对,上面得到的密钥进行第三次处理,拆分为公钥和私钥,避免上面提到的场景.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;TLS1.2&lt;/h2&gt;
&lt;p&gt;上述就是关于 http常见的TLS1.2的简化的握手流程&lt;/p&gt;
&lt;p&gt;这里我们简化了一些可选的 加密过程, mac key 验证数据完整性, iv 加密初始化向量等.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Client                                               Server
   |                                                   |
   |---------------(1) ClientHello--------------------&amp;gt;|
   |                                                   |
   |&amp;lt;--------------(2) ServerHello---------------------|
   |&amp;lt;--------------(3) Certificate---------------------|
   |&amp;lt;-----------(4) ServerKeyExchange------------------|
   |&amp;lt;-----------(5) CertificateRequest(可选)------------|
   |&amp;lt;-----------(6) ServerHelloDone--------------------|
   |                                                   |
   |--------------(7) Certificate(可选)----------------&amp;gt;|
   |-------------(8) ClientKeyExchange----------------&amp;gt;|
   |-------------(9) CertificateVerify(可选)-----------&amp;gt;|
   |-----------(10) ChangeCipherSpec------------------&amp;gt;|
   |--------------(11) Finished-----------------------&amp;gt;|
   |                                                   |
   |&amp;lt;-----------(12) ChangeCipherSpec------------------|
   |&amp;lt;--------------(13) Finished-----------------------|
   |                                                   |
   |==================应用数据传输=======================|
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1. clienthello
- 支持的最高TLS协议版本
- 客户端随机数(Client Random)
- 支持的加密套件列表(Cipher Suites)
- 支持的压缩方法
- 扩展信息
2. serverhello 
- 选择的TLS版本
- 服务器随机数(Server Random)
- 选择的加密套件
- 选择的压缩方法
- 选择的扩展
3. certifcate
- 服务器的证书链
- 包含公钥
- 证书颁发机构(CA)信息
4. serverKeyExchange
- DH或ECDH参数(如果使用)
- 包含签名以防篡改
5. CertificateRequest (可选)
- 要求客户端提供证书
- 指定可接受的证书类型
6. ServerHelloDone
- 表示服务器握手消息发送完毕
7. certificate 客户端证书(可选)
- 如果服务器要求,发送客户端证书
8. clientKeyExchange
- 包含预主密钥(Pre-Master Secret)
- 用服务器公钥加密
9. certificate  可选
- 证明客户端持有私钥
- 对之前所有握手消息的签名
10-12 ChangeCipherSpec
- 通知协商的密钥和加密算法
11-13 finished
- 包含所有握手消息的校验值 
- 协商好的密钥加密

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;预主密钥(Pre-Master Secret)
         ↓
Client Random + Server Random + Pre-Master Secret
         ↓
    主密钥(Master Secret)
         ↓
客户端写密钥  服务器写密钥  MAC密钥  IV
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./file-20241026213301769.png&quot; alt=&quot;https-1.2协议&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;TLS1.3&lt;/h2&gt;
&lt;p&gt;可以看到 复杂度有非常恐怖的提升, 因此 TLS1.3 将流程进行了简化操作.
将所有要传递的加密材料,随机数 合并发送, 使得可以在一个来回建立安全的通信通道.&lt;/p&gt;
&lt;h2&gt;非对称加密不要了?&lt;/h2&gt;
&lt;p&gt;对称加密已经如此强大, 前面的非对称加密是否因此放弃呢? 是的可以放弃
非对称加密首先无法保证绝对的安全, 其次所有的加密内容虽然中间人无法理解但是可以保存,如果服务方内部出现了叛变的情况,那么过去保存的数据就全部遭到了破解,不具备前向保密性.&lt;/p&gt;
&lt;p&gt;解决方式 就是使用动态的密钥, 前面曾经提到 非对称加密的时间复杂度更高,因此使用相对更少.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;至此,TLS 完成了对于HTTP协议的加密, 也就是现在常用的 HTTPS&lt;/p&gt;
&lt;h2&gt;HTTP1.0&lt;/h2&gt;
&lt;p&gt;我们回到 HTTP协议本身 ,如果客户目前有多个访问请求给到服务器, 这产生了一个问题就是每个请求是独立的 便会产生多个TCP协议,反复的创建和销毁TCP套接字产生了不必要的资源消耗.&lt;/p&gt;
&lt;h2&gt;HTTP1.1&lt;/h2&gt;
&lt;p&gt;为了避免反复的创建套接字,HTTP1.1 的版本中引入了一个 keep_alived的机制, 使得不必反复创建套接字,而是共同获取资源使用共同的套接字资源.&lt;/p&gt;
&lt;p&gt;1.1版本在请求上也做到了优化,允许多个请求同时发起,而不必等到响应;
但是引入了一个新的问题, 每个请求的返回结果所占字节可能不同, 后一个可能由于前一个的阻塞导致迟迟不能到达,产生体验上的不畅.&lt;/p&gt;
&lt;h2&gt;HTTP2&lt;/h2&gt;
&lt;p&gt;为了避免1.1的阻塞情况, 2的版本引入了拆包的概念,数据到达后进行重组,这样优化了小数据的到达速度,减少了数据的等待情况.&lt;/p&gt;
&lt;p&gt;这里对于数据的拆包, 依据的原则是将头部帧和数据帧拆分,由于多个网页的请求头部数据高度一直,头部帧的内容往往不需要全部的传递而是可以复用, 那么建立头部索引表,就可以大大降低了时间的消耗.&lt;/p&gt;
&lt;p&gt;至此的HTTP和HTTP2 底层实现都是TCP实现,TCP 自身为了保证自己的面向连接的安全性有序列号和确认号的机制,因此 这两个大版本的HTTP都无法解决 头部阻塞引起的整体阻塞的情况.&lt;/p&gt;
&lt;h2&gt;HTTP3&lt;/h2&gt;
&lt;p&gt;HTTP3中为了摆脱TCP产生的阻塞问题, 优化了底层栈实现, 改用谷歌公司开发的 QUIC协议实现, QUIC的底层是UDP实现
&lt;img src=&quot;./file-20241026174241414.png&quot; alt=&quot;迭代架构变更&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里看到TLS1.3直接嵌入到了 QUIC中 因此也是一个来回的数据传递 就可以建立连接+TLS握手&lt;/p&gt;
&lt;p&gt;从实际情况考虑, HTTP2 仍然还是协议使用的主流,可能是如下原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UDP可能被防火墙封堵&lt;/li&gt;
&lt;li&gt;故障排查工具不完善&lt;/li&gt;
&lt;li&gt;性能监控方案不成熟&lt;/li&gt;
&lt;li&gt;部分中间件(nginx, haproxy) CDN等 支持有限&lt;/li&gt;
&lt;li&gt;对老的客户端环境的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑到篇幅, 部分协议细节有所缺失,感兴趣可以自行查阅:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS 缓存机制 TTL 记录类型等&lt;/li&gt;
&lt;li&gt;HTTP 的请求方法区别 GET POST PUT等 常见状态码表达的意思&lt;/li&gt;
&lt;li&gt;TLS Session复用机制&lt;/li&gt;
&lt;li&gt;HTTP2 多路复用&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;其中几个主题也可以展开实践,后续可能深入讨论.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络性能优化实践&lt;/li&gt;
&lt;li&gt;HTTPS部署最佳时间&lt;/li&gt;
&lt;li&gt;常见网络问题排查案例&lt;/li&gt;
&lt;li&gt;网络安全实践指南&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>本博客基本使用方法</title><link>https://fuwari.vercel.app/posts/guide/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/guide/</guid><description>如何使用这份模板？</description><pubDate>Sat, 19 Oct 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Cover image source: &lt;a href=&quot;cover.jpg&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此博客模板是由 &lt;a href=&quot;https://astro.build/&quot;&gt;Astro&lt;/a&gt;. 对于本指南中未提及的内容，您可能会在 &lt;a href=&quot;https://docs.astro.build/&quot;&gt;Astro Docs&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;帖子的前后&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;---
title: 我的第一篇博客文章
published: 2024-09-09
description: 这是我新的Astro博客的第一篇文章.
image: ./cover.jpg
tags: [Foo, Bar]
category: Front-end
draft: false
---
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;title&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标题.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;published&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;发布日期.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;description&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;帖子的简短描述。显示在索引页面上.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;image&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;帖子的封面图像路径.&amp;lt;br/&amp;gt;1. 网络图片 &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;: &amp;lt;br/&amp;gt;2. 本地图片  &lt;code&gt;/&lt;/code&gt;: 在 &lt;code&gt;public&lt;/code&gt; 目录&amp;lt;br/&amp;gt;3. 没有前缀：相对于md文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;帖子的标签.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;帖子的类别.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;draft&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果这篇文章仍然是草稿，那将不会显示.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;在哪里放置文件&lt;/h2&gt;
&lt;p&gt;您的帖子文件应放置在&lt;code&gt;src/content/posts/&lt;/code&gt;目录中。您还可以创建子目录以更好地组织您的帖子和资产。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src/content/posts/
├── post-1.md
└── post-2/
    ├── cover.png
    └── index.md
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;语法&lt;/h2&gt;
&lt;p&gt;段落用空白行分开。&lt;/p&gt;
&lt;p&gt;第二段。 &lt;em&gt;斜体&lt;/em&gt;，&lt;strong&gt;粗体&lt;/strong&gt;和 &lt;code&gt;单域&lt;/code&gt;。逐项列表
看起来像：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个&lt;/li&gt;
&lt;li&gt;那个&lt;/li&gt;
&lt;li&gt;另一个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意 ---不考虑星号--- 实际文本
内容从4个列开始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;块引号为
像这样写。&lt;/p&gt;
&lt;p&gt;它们可以跨越多个段落，
如果您愿意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用3个破折号进行EM仪表板。使用2个破折号进行范围（例如，“全部
在第12--14章中）。三个点...将转换为省略号。支持Unicode。 ☺&lt;/p&gt;
&lt;h2&gt;H2标头&lt;/h2&gt;
&lt;p&gt;这是一个编号列表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再次注意实际文本如何以4列的4列开始（4个字符
从左侧）。这是一个代码样本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Let me re-iterate ...
for i in 1 .. 10 { do-something(i) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正如您可能猜到的那样，缩进了4个空间。顺便说一句，而不是
缩进块，如果您愿意，可以使用划界块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define foobar() {
    print &quot;Welcome to flavor country!&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（这使复制和粘贴更容易）。您可以选择标记
pandoc的划界块以语法强调了它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time
# Quick, count to ten!
for i in range(10):
    # (but not *too* quick)
    time.sleep(0.5)
    print i
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;H3标头&lt;/h3&gt;
&lt;p&gt;现在一个嵌套列表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，获取这些成分：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;胡萝卜&lt;/li&gt;
&lt;li&gt;芹菜&lt;/li&gt;
&lt;li&gt;小扁豆&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;煮一些水。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将所有东西都倾倒在锅中并跟随
该算法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; find wooden spoon
 uncover pot
 stir
 cover pot
 balance wooden spoon precariously on pot handle
 wait 10 minutes
 goto first step (or shut off burner when done)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不要撞木勺，否则会掉落。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再次注意文本如何始终在4空间凹痕上排队（包括
最后一行继续上述项目3）。&lt;/p&gt;
&lt;p&gt;这是&lt;a href=&quot;http://foo.bar&quot;&gt;网站&lt;/a&gt;，&lt;a href=&quot;localdoc.html&quot;&gt;localdoc&lt;/a&gt;的链接，以及&lt;a href=&quot;#%E8%AF%AD%E6%B3%95&quot;&gt;currentDoc中的一个部分&lt;/a&gt;。这是一个脚注  &lt;a href=&quot;%E8%84%9A%E6%B3%A8%E7%9A%84%E6%8F%8F%E8%BF%B0%E3%80%82&quot;&gt;^1&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;视频插入&lt;/h1&gt;
&lt;p&gt;只需从YouTube或其他平台复制嵌入代码，然后将其粘贴到Markdown文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: Include Video in the Post
published: 2023-10-19
// ...
---

&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://youtu.be/aB3R3O-Ak5Y?si=Q9rFt4GbWLAZ82jT&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;YouTube&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;800&quot; height=&quot;400&quot; src=&quot;https://www.youtube.com/embed/aB3R3O-Ak5Y?si=Q9rFt4GbWLAZ82jT&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; referrerpolicy=&quot;strict-origin-when-cross-origin&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;Bilibili&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;800&quot; height=&quot;500&quot;  src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;amp;aid=1205434445&amp;amp;bvid=BV1gf421X771&amp;amp;cid=1566619993&amp;amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;h1&gt;扩展语法&lt;/h1&gt;
&lt;h2&gt;GitHub 代码库卡片&lt;/h2&gt;
&lt;p&gt;您可以添加动态卡片，链接到 GitHub 代码库，页面加载时，代码库信息从 GitHub API 中获取。&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;alongnice/myddns&quot;}&lt;/p&gt;
&lt;p&gt;使用代码 &lt;code&gt;::github{repo=&quot;&amp;lt;owner&amp;gt;/&amp;lt;repo&amp;gt;&quot;}&lt;/code&gt; 创建一个 GitHub 代码库卡片。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;::github{repo=&quot;saicaca/fuwari&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;警告框&lt;/h2&gt;
&lt;p&gt;以下类型的警告框受到支持: &lt;code&gt;note&lt;/code&gt; &lt;code&gt;tip&lt;/code&gt; &lt;code&gt;important&lt;/code&gt; &lt;code&gt;warning&lt;/code&gt; &lt;code&gt;caution&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;:::note
突出显示用户应考虑的信息，即使快速浏览。
:::&lt;/p&gt;
&lt;p&gt;:::tip
可选信息，以帮助用户更成功。
:::&lt;/p&gt;
&lt;p&gt;:::important
至关重要的信息，对于用户成功至关重要。
:::&lt;/p&gt;
&lt;p&gt;:::warning
由于潜在风险，需要立即引起用户注意的关键内容。
:::&lt;/p&gt;
&lt;p&gt;:::caution
行动的负面潜在后果。
:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::note
突出显示用户应考虑的信息，即使快速浏览。
:::

:::tip
可选信息，以帮助用户更成功。
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;警告框的标题可以自定义。&lt;/p&gt;
&lt;p&gt;:::note[MY CUSTOM TITLE]
这是一个带有自定义标题的提示。
:::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::note[MY CUSTOM TITLE]
这是一个带有自定义标题的提示。
:::
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
&lt;a href=&quot;https://github.com/orgs/community/discussions/16925&quot;&gt; GitHub 语法&lt;/a&gt; 也支持.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [!NOTE]
&amp;gt; GitHub 语法也受支持。

&amp;gt; [!TIP]
&amp;gt; GitHub 语法也受支持。
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item></channel></rss>