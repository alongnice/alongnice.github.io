<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>阿龙种树</title><description>全栈放</description><link>https://fuwari.vercel.app/</link><language>zh_CN</language><item><title>踏雪之死与心灵的放牧——论生命中那些不得不放的箭</title><link>https://fuwari.vercel.app/posts/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AE%A8%E8%AE%BA%E6%85%A2%E6%97%B6%E6%88%91%E4%BB%AC%E5%9C%A8%E6%8A%B5%E6%8A%97%E4%BB%80%E4%B9%88/%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%88%E8%AE%BA%E6%85%A2%E6%97%B6%E6%88%91%E4%BB%AC%E5%9C%A8%E6%8A%B5%E6%8A%97%E4%BB%80%E4%B9%88/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AE%A8%E8%AE%BA%E6%85%A2%E6%97%B6%E6%88%91%E4%BB%AC%E5%9C%A8%E6%8A%B5%E6%8A%97%E4%BB%80%E4%B9%88/%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%88%E8%AE%BA%E6%85%A2%E6%97%B6%E6%88%91%E4%BB%AC%E5%9C%A8%E6%8A%B5%E6%8A%97%E4%BB%80%E4%B9%88/</guid><description>我们所追求的和我们所放弃的,一样值得珍惜</description><pubDate>Mon, 30 Jun 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;这是一部慢得不太像“国产剧”的国产剧。没有惊天动地的转折，也没有精心设计的爽点。&lt;/p&gt;
&lt;p&gt;它讲的是一个女孩回到新疆阿勒泰，与母亲共同生活的故事。有人选择留下，有人想要离开；有人热烈地爱着，有人默默守护；有人挣扎着做选择，有人坦然面对别离。&lt;/p&gt;
&lt;p&gt;它的节奏像风吹草原一样缓慢，却时不时让你心里“咯噔”一下；像是讲了一些不重要的小事，却总能撞上你心里那些不太好说出口的情绪。&lt;/p&gt;
&lt;p&gt;你很难说这部剧“讲了一个什么完整的故事”，它更像是记录了一种&lt;strong&gt;生活的质感&lt;/strong&gt;：&lt;br /&gt;
那种你以为早就丢掉了的，真实、原始、不设防的生命力。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;一、我们早就学会了想太多&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;不是说自己有多聪明，而是这几年，活得太像在解题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;说句话得先掂量人设、立场、走向&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟人交往要设边界、做筛选、打标签&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;爱一个人都得先过三四道风控流程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;哪怕只是别人笑一下，你脑子里都能推演出三种动机五种可能。&lt;/p&gt;
&lt;p&gt;以前觉得这叫成熟，现在觉得这叫累。&lt;/p&gt;
&lt;p&gt;我在看《我的阿勒泰》的时候突然想问：&lt;br /&gt;
&lt;strong&gt;我们到底是活着，还是在演“活着”这件事？&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;二、那一箭，我没法忘&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;那一箭，真的不是悲伤，是&lt;strong&gt;震惊&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;踏雪不是被敌人杀的，不是意外死的，是被巴太亲手一箭穿喉的。&lt;/p&gt;
&lt;p&gt;我们都知道那匹马对他意味着什么。&lt;/p&gt;
&lt;p&gt;但他没哭，也没犹豫，就那么拉弓、放箭、低头收场。&lt;/p&gt;
&lt;p&gt;不是因为“传统”或者“情怀”，而是他知道：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;到这一步了，非放不可了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们呢？&lt;br /&gt;
不是没遇到过必须放手的时候。&lt;br /&gt;
只不过我们会拖、会绕、会装看不见。&lt;/p&gt;
&lt;p&gt;—&lt;/p&gt;
&lt;p&gt;城市不是问题，逻辑不是问题，&lt;br /&gt;
问题是：&lt;strong&gt;我们太怕承认结束。&lt;/strong&gt;
&lt;img src=&quot;file-20250630150150766.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;三、不是没情绪，是不会面对了&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;剧里那些看起来“傻”的事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;把喝醉的陌生人带回家&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;借出一辈子积蓄就为了口头承诺&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为一场临时婚礼倾尽所有&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;换成我们，谁敢？谁不是马上想“这人是不是想骗我”？&lt;br /&gt;
可你说他们傻吗？也不是。只是他们还敢相信。&lt;/p&gt;
&lt;p&gt;我们不是不相信，而是——&lt;br /&gt;
我们&lt;strong&gt;连被骗的资格都怕拥有&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以我们就用理性把情绪包起来，用推理掩盖信任，用计划隔绝痛苦。&lt;br /&gt;
最后成了一个很冷静、很稳重，但也很难被真正触碰的人。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;四、我们缺的，不是智慧，是“结束力”&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;没人教我们怎么结束。&lt;/p&gt;
&lt;p&gt;怎么收一段感情、怎么扔一个执念、怎么认输、怎么说“我不行了”。&lt;/p&gt;
&lt;p&gt;所以我们啥都不结束，就堆着、藏着、绕着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;微信不删，聊天不回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作不换，但天天内耗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;人不爱了，还一起过节&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们以为“拖着”是缓冲，其实是慢性耗命。&lt;/p&gt;
&lt;p&gt;阿勒泰那帮人，不是有多懂生死，是&lt;strong&gt;太习惯面对“没办法”的时候了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以才显得干净。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;五、别再扛着了，试着练练放手&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;你可以找个方式练习：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;写一封信给过去的人，写完烧了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把旧照片丢进硬盘深处，别随便翻&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找个好朋友，说一次：“我真的不行了。”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;别装。&lt;br /&gt;
我们都没那么坚强。&lt;/p&gt;
&lt;p&gt;但也别怕。&lt;br /&gt;
人生不是非要赢才能继续走。&lt;/p&gt;
&lt;p&gt;你看巴太，踏雪死了，但他还得赶路。&lt;br /&gt;
马鞍还在，草原还在，雪照样落下。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;六、活成那样，不浪漫，但很实在&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;张凤侠那句：“疼的时候就大声哭，但别耽误明天挤牛奶。”&lt;/p&gt;
&lt;p&gt;我以前以为这句话太鸡汤。&lt;/p&gt;
&lt;p&gt;现在懂了，这是活着最真实的状态——&lt;br /&gt;
你可以崩溃，但不能一直躺着；&lt;br /&gt;
你可以难过，但明天早上，太阳还会照样升起。&lt;/p&gt;
&lt;p&gt;这剧教我的，不是“去做更好的人”，而是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;别把“活下去”搞得那么复杂。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候，活着就是该哭就哭，该放就放，然后接着走。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;file-20250630150257805.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>串口通讯开发排错实录</title><link>https://fuwari.vercel.app/posts/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E5%BC%80%E5%8F%91%E6%8E%92%E9%94%99%E5%AE%9E%E5%BD%95/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E5%BC%80%E5%8F%91%E6%8E%92%E9%94%99%E5%AE%9E%E5%BD%95/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E5%BC%80%E5%8F%91%E6%8E%92%E9%94%99%E5%AE%9E%E5%BD%95/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E5%BC%80%E5%8F%91%E6%8E%92%E9%94%99%E5%AE%9E%E5%BD%95/</guid><description>关于rs485串口通讯的问题汇总</description><pubDate>Mon, 24 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&amp;lt;!-- Cover image source: &lt;a href=&quot;image.png&quot;&gt;alt text&lt;/a&gt; --&amp;gt;&lt;/p&gt;
&lt;h1&gt;记录一下关于 &lt;code&gt;rs485&lt;/code&gt;协议开发灵巧手遇到的所有问题&lt;/h1&gt;
&lt;h1&gt;1. 验证灵巧手是否通电&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;通电后左手大拇指根部,机械结构缝隙露出红光或者绿光证明通电成功&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;2. 验证灵巧手能接收到内容&lt;/h1&gt;
&lt;p&gt;首先我们要确定我们能发送出去内容
## 2.1. 验证我们可以发出rs485的内容
从设备出口出发 我们需要知道 转接器是否能够发送出去内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件接线是 A对A B对B 确定颜色就好&lt;/li&gt;
&lt;li&gt;对于机器人 来说 黄A 蓝B 黑或棕接地&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RS485 通信是通过两根信号线的高低电平差来读取内容 这意味着不能通过短接AB来看数据是否发送&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里我想到的思路是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;USB-&amp;gt;RS485 -------------------&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;-----------------RS485-&amp;gt;USB
此处的2个USB都连在一个电脑上, 开启两个串口
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RS485 通信时 双向半双工的 依次确定能否发送数据   避免转接器的问题导致后续问题不方便排查&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]
小贴士: 一般情况(不绝对)下,转接器会发送和接收内容,会有不同的闪光,也可以辅助查看数据的通信情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2.2. 驱动问题&lt;/h2&gt;
&lt;p&gt;关于转接器, 我们还需要考虑驱动问题, 不见得所有的设备都只是用 ch340 或者 ch341 就能对串口进行操作
注意查看转接器包装是否提供了 驱动下载链接
也可以直接导致 &lt;em&gt;数据不能发送&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;至此, 硬件连接问题解决, 驱动问题解决,下一步验证灵巧手能否响应内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;2.3 win平台下上位机使用 或 调用串口&lt;/h2&gt;
&lt;p&gt;灵巧手提供了开发的上位机程序,值得注意的是,&lt;em&gt;串口在同一时间通常只能被一个进程打开&lt;/em&gt;,意味着其他串口工具和通信方式要关闭
在没有阅读 参数列表的时候 建议使用上位机控制 避免特殊符号或者误触导致的 无响应
&lt;img src=&quot;./%E4%B8%8A%E4%BD%8D%E6%9C%BA%E5%9B%BE%E7%89%87.png&quot; alt=&quot;上位机图片&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里非常建议使用 可以拉去左侧进度条 或者 传感器标准(使用前记得连接搜索)
或者按照文档 串口发送内容
EB 90 01 04 12 F1 03 01 0C
这个校准期间 尽量不要接触 灵巧手&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;至此 我们证明了灵巧手的响应没有问题了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h1&gt;3. 如何利用工控机操作RS485串口&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;linux 上一切内容皆文件, rs485 也将映射到 文件中 一般考虑如下几个文件 &lt;code&gt;/dev/ttyS0~5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这里主要看 ttyS0 和 ttyS1&lt;/li&gt;
&lt;li&gt;众所周知, /dev 目录下很多文件 都是字符设备映射文件 跟普通的文件操作上略有不同&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.1. 如何证明我们对串口发送了数据呢 ?&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;	sudo cat /proc/tty/drive/serial
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会记录这个串口 发送和接受的数据
&lt;img src=&quot;%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1.png&quot; alt=&quot;串口数据统计&quot; /&gt;
每次尝试发送后 查看tx后面的数值是否发生变化&lt;/p&gt;
&lt;h2&gt;3.2. 如何给这个串口发送数据呢?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;串口的字符文件描述符有如下特点&lt;/li&gt;
&lt;li&gt;丰富的标志位需要设置,下面会提到&lt;/li&gt;
&lt;li&gt;这些标志位每次重启后,都会丢失会被初始化为原本的样子,需要设置&lt;/li&gt;
&lt;li&gt;我们发送内容也应当注意 波特率 数据位 停止位 完整性校验方法等&lt;/li&gt;
&lt;li&gt;字符设备的操作区别于普通文件, 他不具备缓冲区, 是以流的方式运行的,只能存储单个字符
&lt;ul&gt;
&lt;li&gt;而不是所有操作工具 都有针对这种场景适配 因此一些基础工具可能不太好用&lt;/li&gt;
&lt;li&gt;这里的字符设备 要注意跟上面的串口一样 也具备一些独占的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.2.1. 有哪些参数需要预设呢?&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  stty -F /dev/ttyS1 115200 cs8 -parenb  -cstopb  -ixon -ixoff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体参数内容,没有细察,可以后期补充,项目紧急草草过下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果后需要代码开发,系统编程提供了合适的内容支持&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;3.2.2. 发送数据&lt;/h3&gt;
&lt;p&gt;建议使用 工具 screen&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先说说怎么退出,这个程序的退出比较复杂,类似 vim , 如果没有正常退出释放字符设备,就会被独占不能操作
&lt;ul&gt;
&lt;li&gt;首先  ctrl+a 进入命令模式 然后 &lt;code&gt;:quit&lt;/code&gt; 输入命令 就可以退出了&lt;/li&gt;
&lt;li&gt;如果不小心命令行被关掉或者其他方式关掉, 这个进程可能还会保留在后台不会死&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screen -ls&lt;/code&gt;  查看存活的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screen -X -S &amp;lt;session_id&amp;gt; quit&lt;/code&gt;  这里id 替换成 上面查到的4~5位的数字id就好&lt;/li&gt;
&lt;li&gt;可以再次查看存活状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;下面正式开始 怎么打开这个会话&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;screen /dev/ttyS1 &amp;lt;波特率&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后会出现一个黑框,你所有的键盘内容都会实时输入进去,没有回显&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里建议工控机和开发机器的网线和485通道都打开&lt;/li&gt;
&lt;li&gt;也就是 网线保证 ssh 的信道通信&lt;/li&gt;
&lt;li&gt;485 通道 在开发机器 打开UBS转485的串口 接收数据&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果说我们能够顺利的发送了数据, 开发机器的串口工具也准确的收到了内容,那么我们证明了 工控机的RS485 和 设备挂载是没有问题的
关于接收到的内容 输入的内容会默认为字符串 会被转换成ASCII码  然后会转为16进制内容  也就是说&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果 发送键盘上的 0  对面是 0x30&lt;/li&gt;
&lt;li&gt;发送1 对应 0x31&lt;/li&gt;
&lt;li&gt;发送A 对应 0x41   -&amp;gt; 也就是65&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后也可以给工控机发送数据   内容会直接打印出来  应该是自动有做转码处理  会直接输出明文&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!CAUTION]
如果是乱码,记得详细查看 A对A  B对B  不要接反&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;p&gt;总结一下 我们验证了 如下内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发机器的串口发送能力&lt;/li&gt;
&lt;li&gt;USB转RS485 的设备健康&lt;/li&gt;
&lt;li&gt;机器手的接收和发送能力&lt;/li&gt;
&lt;li&gt;机器手的动作能力&lt;/li&gt;
&lt;li&gt;工控机的串口发送能力和接收能力
&lt;img src=&quot;./%E7%81%B5%E5%B7%A7%E6%89%8B%E9%80%9A%E4%BF%A1.png&quot; alt=&quot;灵巧手通信&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h1&gt;4. 是否发送?发送了什么?&lt;/h1&gt;
&lt;p&gt;针对3.1章节 我们有提到 我们确定自己发送了数据,但是这仅仅是针对于发送方.
假设我们跳过了前面的部分,在此处发送内容依旧可以显示内容? 但是如何证明 如下几点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我发送的东西有通过线路出去了呢(前面提到USB转RS485转接器可以依稀看到)&lt;/li&gt;
&lt;li&gt;我们发送出去的内容是我们原本的意思吗? 会不会字符串转了ascii码或者以错误的格式发送了出去&lt;/li&gt;
&lt;li&gt;有些上位机的功能 我不知道怎么实现的 我能不能知道上位机发送了哪些东西 &lt;s&gt;抄&lt;/s&gt;借鉴一下&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;4.1. 理解通信场景&lt;/h2&gt;
&lt;p&gt;目前来看, 我们的开发目的是单线通信的方式,有什么内容的对话只有工控机和灵巧手之间知道.
而且对于工控机(这里pc也一样)来说串口这个东西将会被独占,不方便(也许系统调用或者ebpf可以)从软件层面进行监控.
那么我们从硬件层面考虑,将其中的硬件通信构建一个广场,让他们之间的对话完全成为一个公开的内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!CAUTION]
这里的全部操作断电操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;首先我们将pc端的转接口A对准工控机的接口A,对应的B对应B&lt;/li&gt;
&lt;li&gt;然后对连接的电线 开环- 将其中一部分的塑料皮剥开 然后将灵巧手的信号线并联上 注意! 依旧是A对A B对B
线路连接 大致如下
&lt;img src=&quot;%E5%B9%BF%E5%9C%BA%E9%80%9A%E8%AE%AF.png&quot; alt=&quot;广场通讯&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如此一来,我们能将得到一个广播广场,效果如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PC上位机发送的所有内容 + 灵巧手给的响应 工控机都可以监听到(不过上位机发送内容超级频繁,需要使用过滤工具)&lt;/li&gt;
&lt;li&gt;工控机发送的所有内容 + 灵巧手的响应 PC都可以通过串口调试工具监听到&lt;/li&gt;
&lt;li&gt;工控机给了错误的指令 导致灵巧手故障 上位机可以快速清理故障以及复位&lt;/li&gt;
&lt;li&gt;因为任何原因导致 工控机的参数 实质上没有对外发送 也可以看到&lt;/li&gt;
&lt;li&gt;串口调试助手可以快速 试验 命令帧&lt;/li&gt;
&lt;li&gt;避免了频繁的接线问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;4.2 新场景是否引入了问题&lt;/h2&gt;
&lt;p&gt;目前来看,新的通信方式更多的是带来优势.
但是引入了一些小问题 以及对于一些已有问题,我们更加清晰&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于单个发送端也就是单个pc或者工控机而言, 串口是独占的, 在软件层面, 但是我们开发的过程如果无意多开或冲突会引发什么问题呢
&lt;ul&gt;
&lt;li&gt;基本无法预知.&lt;/li&gt;
&lt;li&gt;对于pc,我们无需过多关注 串口工具和上位机的无法连接,会提醒我们&lt;/li&gt;
&lt;li&gt;对于工控机,我开发了一个小脚本,用来自动清理冗余进程的小脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

# 检查是否以 root 用户运行
if [ &quot;$EUID&quot; -ne 0 ]; then
  echo &quot;请以 root 用户运行此脚本。&quot;
  exit 1
fi

# 获取占用 /dev/ttyS1 的所有进程 ID
pids=$(sudo lsof /dev/ttyS1 | awk &apos;NR&amp;gt;1 {print $2}&apos;)

# 如果没有进程占用，则退出
if [ -z &quot;$pids&quot; ]; then
  echo &quot;没有进程占用 /dev/ttyS1。&quot;
  exit 0
fi

# 杀死所有相关进程
echo &quot;正在杀死以下进程：&quot;
echo &quot;$pids&quot;
kill -9 $pids

# 检查是否成功
if [ $? -eq 0 ]; then
  echo &quot;所有占用 /dev/ttyS1 的进程已成功终止。&quot;
else
  echo &quot;终止进程时出错。&quot;
  exit 1
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;对于pc和工控机的使用场景, 这句话可以改为 “通常情况下，应避免 PC 上位机和工控机同时向灵巧手发送指令，&lt;strong&gt;除非在排错过程中&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4.3 如何通过pc串口工具监听通信呢?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;%E5%B9%BF%E6%92%AD.png&quot; alt=&quot;广播.png&quot; /&gt;
这里写了个受力传感器的例子&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;被ssh连接工控机发送指令后 灵巧手会有2个响应 一个立即响应开启动作 另一个动作完成&lt;/li&gt;
&lt;li&gt;从串口调试助手这边来看 接收到 看似2条指令
&lt;ol&gt;
&lt;li&gt;第一条略长 因为对于pc来说 工控机发送和灵巧手的响应 都是接收者&lt;/li&gt;
&lt;li&gt;第二条略短 是灵巧手的动作完成响应&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这里由于是连续的 个人建议 通过串口调试工具的过滤功能分段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;直接搜索 90 EB 这里是 接收包的包头 那么此处之前的内容 就是发送方的内容
如果使用串口快速测试一下帧内容 则可以
&lt;img src=&quot;%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF.png&quot; alt=&quot;串口通讯&quot; /&gt;
更清晰的区分发送方和接收方&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;如何通过PC工控机监听上位机通讯?&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cat /dev/ttyS1 | od -t x1 -v
...
0714220 94 06 04 03 fe 06 a4 04 64 0b f2 ff ff ff 80 80
0714240 fe ec ff ff ff ff 00 00 00 04 04 04 04 04 04 04
0714260 04 04 04 04 04 04 04 04 04 04 04 24 24 24 24 24
0714300 24 24 e0 e0 62 1e 22 bd eb 90 ff 04 11 0a 06 4e
0714320 72 d8 c0 fe 66 ec 8c f0 fe 30 70 ff f8 ff 18 e0
0714340 0e bc 0e 0c 07 e6 07 3e 06 36 6f f6 ff 8c 80 80
0714360 80 ff ff 84 80 84 80 80 80 80 80 80 80 80 80 00
0714400 80 80 00 80 00 00 80 00 00 03 02 02 02 02 06 20
0714420 20 26 20 1e 24 a4 eb 90 ff 04 11 0a 06 4e 72 90
0714440 eb 01 51 11 0a 06 e8 03 e7 03 e8 03 e6 03 e7 03
0714460 dc 03 8f 00 99 00 a0 00 9f 00 08 00 a7 01 fe ff
0714500 ff ff fe ff 0c 00 ff ff 00 00 fe ff ff ff fe ff
0714520 00 00 ff ff 00 00 00 00 00 00 00 00 00 00 00 00
0714540 00 00 00 00 00 00 00 00 02 02 02 02 02 06 20 20
0714560 20 20 1e 20 a6 eb 90 ff 04 11 0a 06 4e 72 90 eb
0714600 01 51 11 0a 06 e8 03 e7 03 e8 03 e6 03 e6 03 dc
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过列处理工具 全部导出 然后通过 eb 90 和 90 eb 关键字
将命令的发送帧和接收帧 再可以通过自己针对功能的设定参数 进行二次过滤 即可&lt;/p&gt;
</content:encoded></item><item><title>客户端到服务端边界</title><link>https://fuwari.vercel.app/posts/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BE%B9%E7%95%8C/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BE%B9%E7%95%8C/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BE%B9%E7%95%8C/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BE%B9%E7%95%8C/</guid><description>从一个url链接点击下去，到到达服务端边界之间的所有事情</description><pubDate>Tue, 29 Oct 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;前缀知识, TCP/IP协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;DNS协议&lt;/h2&gt;
&lt;p&gt;本文将探讨互联网最常见的http请求的完整流程,首先我们了解到早于 http3.0 之前, 协议使用的TCP的网络协议,可以根据 源ip端口+目标IP端口+协议的方式 进行网络通信. 考虑到ip和端口都是数字不便记忆,域名便成为了主要的操作参数. 于是我们可以建立一个类似电话本的方式,映射域名和ip+端口的方式.
&lt;img src=&quot;./file-20241026153513873.png&quot; alt=&quot;域名&quot; /&gt;
对于一个 linux 客户的机器, /etc/hosts 文件就是这个电话本&lt;/p&gt;
&lt;p&gt;但是从实际考虑, 这个表的内容完全有可能更新,频繁的更改本地这个文件是不现实的. 而且考虑到我们的网络安全情况,这个文件在系统中有很高的权限,不会允许普通用户进行改动,所以我们的实际用到的映射信息在其他的文件中 可以通过命令查看, 我们的浏览器一般也会单独缓存一份.&lt;/p&gt;
&lt;p&gt;然而本地存储全球所有的域名表这并不现实, 即使使用一个完整的机器存储压力也是很大的, 而且并不适用于跨设备共享, 所以会有组织进行域名服务器的架设,而我们只需要设置系统的域名到达这个电话本的位置进行查询即可.&lt;/p&gt;
&lt;p&gt;对于域名服务器而言,需要应对所有网络访问设备的访问也难以承载, 因此会引入一种负载均衡的思想,将用户的请求按照特征进行分流.
例如我们要访问 &lt;code&gt;pan.baidu.com&lt;/code&gt;的域名;
那么我们将访问 DNS根服务器 根服务器看到我是 &lt;code&gt;.com&lt;/code&gt; 结尾,给到我顶级DNS服务器的地址;
我们访问&lt;code&gt;.com&lt;/code&gt;对应的顶级域名服务器, 可以找到是 &lt;code&gt;baidu.com&lt;/code&gt; ,给到我权威DNS服务器的地址;
我们访问&lt;code&gt;baidu.com&lt;/code&gt;的权威DNS服务器, 权威DNS服务器,理解到这是 &lt;code&gt;pan.baidu.com&lt;/code&gt;给到我们具体的业务服务器的IP+端口(这里指的是业务侧负载均衡层的地址,属于是业务对外暴露的但不是实际处理业务的)&lt;/p&gt;
&lt;p&gt;那么经过一套复杂的情况我们访问到了, 我们考虑到这个过程的复杂性, 网络运行商一般也会提供一层的代理服务, 对于这一套的寻路信息进行暂存.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./file-20241026155320328.png&quot; alt=&quot;dns协议&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从这个图片中,抛开客户的软件, 其他内容共同组成 DNS服务.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;HTTP协议&lt;/h2&gt;
&lt;p&gt;如此,我们形成了网络层面的业务通路. 前面我们提到,早期包括目前还在使用的http协议大多使用TCP 完成实现.&lt;/p&gt;
&lt;p&gt;在TCP的三次握手建立面向连接的通信后;
通过发送特殊构成的 http 请求字符结构 来完成客户端服务申请;
而对于服务器端来说, 队协议栈进行逆向的操作;
根据 请求头 实际的业务请求进行处理返回;
用户侧的浏览器等工具会将内容按照预设的格式展示出来;
然后TCP的四次挥手结束,双方断开连接&lt;/p&gt;
&lt;p&gt;下图是关于 http 请求一个基本的格式
&lt;img src=&quot;./file-20241026160130555.png&quot; alt=&quot;http请求&quot; /&gt;
而服务端的回复 往往也有相对固定的结构
&lt;img src=&quot;./file-20241026160320323.png&quot; alt=&quot;http响应&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;中间人攻击&lt;/h2&gt;
&lt;p&gt;这里有一个隐患,关于 http 所有网络数据的传递是明文的,这意味着在多个网络路由跳转的过程中, 中间人都可以对内容进行查阅和篡改, 形成了非常不安全的情况.
所以加密行为成了不得不引入的方案了, 这很经典 加解密的行为出现得比计算机还要早.&lt;/p&gt;
&lt;h3&gt;对称加密&lt;/h3&gt;
&lt;p&gt;假设 A B两个人都用同一个保险箱传递内容, 使用着相同的钥匙,那么中间的恶意者无法打开保险箱,无法查看和篡改,所以数据是安全的.
但是钥匙我该怎么给到另一个人呢, 如果传递钥匙的时候就已经被获取复制,那么 相当于中间人还是可以查看和篡改,这很糟糕.
常用的对称加密有 AES DES 等&lt;/p&gt;
&lt;h3&gt;非对称加密&lt;/h3&gt;
&lt;p&gt;同样是上面的场景, 假设A和B可以不同的钥匙, A上锁后只能交给B来解锁, B加密后只能交给A来解锁.
我们回到上面的场景,假设B有两把钥匙, 将公钥下发给客户A,中间人也偷偷拿到了公钥,客户A通过公钥加密了, 那么数据只能使用B手上的私钥进行解密了,那么数据包回传的时候,中间人再想使用前面偷到的公钥解密,是做不到的.所以数据只能在服务器端通过私钥解密.&lt;/p&gt;
&lt;p&gt;常用的非对称加密有RSA 等&lt;/p&gt;
&lt;p&gt;当我们以为非对称加密是无敌的时候, 中间人的策略进行了升级, 我试图在服务端发出公钥的时候 就进行篡改替换成了自己的公钥, 继续发给客户,客户并不知情进行加密,发送了请求,由于密钥是中间人给的,那么中间人可以有自己私钥解密,然后还原成原本的服务端公钥加密版本.&lt;/p&gt;
&lt;p&gt;在这个场景下, 客户和服务端都不知道自己的数据是否被查阅和修改.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;ca 证书机制&lt;/h2&gt;
&lt;p&gt;上一个场景, 我们即使使用了非对称加密也无法保证信息传递的安全性,似乎只有通过网络之外的其他渠道进行密钥的传递, 这当然是不现实的. ca机构应运而生.&lt;/p&gt;
&lt;p&gt;首先,服务端会在业务上线之前 将自己的域名,公钥等信息发送给ca机构
ca机构审核后,使用公钥将内容加密给回服务端; --- 这里发送的就是证书
再将ca私钥发给客户端;&lt;/p&gt;
&lt;p&gt;上线后的业务场景
服务端先将加密后的证书发送给客户;
客户拥有ca机构发送的私钥,因此能够解析;
如果这个时候中间人获取到包,因为不具备ca的私钥所以数据无法操作
客户根据证书内部的细节,进行后续与服务端的加解密&lt;/p&gt;
&lt;p&gt;这里 关于证书的内容 是对服务端发送内容进行一定的哈希操作 然后对哈希进行加密 因此会保留一部分明文细节.&lt;/p&gt;
&lt;p&gt;这里ca机构和服务端 可能使用丰富的方式来降低证书生成过程的安全问题;
而客户端普通用户明明没有跟ca机构打过交道,为何会有密钥呢? 这个一般是操作系统自带或者浏览器自带&lt;/p&gt;
&lt;p&gt;由于服务业务的庞杂, 跟DNS一样, ca机构一般也是用类似的分层机构的情况;
那么在这个机构中 我们又该如何避免 ca机构是有问题的呢? 这里引入了一个新的概念 透明透明机制
就是所有ca发放证书的时候,需要往日志服务器发送数据,日志的可读权限是共享的,由于ca机构一般也是盈利机构,因此相对的管控下可以保证相对的安全.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非对称加密对比对称加密,从算法复杂度上考虑,更加费时,文件也更大;
所以日常加密的过程,不会使用非对称加密进行通信,而是用来传递对称加密的密钥,进行日常通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;DH密钥交换&lt;/h2&gt;
&lt;p&gt;对于上面提到的密钥交换的场景还有一种数学上的实现,能够简化优化这个过程,那就是DH密钥算法&lt;/p&gt;
&lt;p&gt;首先基于数学的一个概念&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a^x mod p = y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;知道x 计算这个y非常容易,但是知道y 计算x非常困难&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Alice                         Bob
  |                            |
  |------ 公共参数 p,g -------&amp;gt;|   (p是大素数,g是p的原根)
  |                            |
  |--- g^a mod p (A值) ------&amp;gt;|    (a是Alice的私钥)
  |&amp;lt;---- g^b mod p (B值) -----|    (b是Bob的私钥)
  |                            |
计算: B^a mod p          计算: A^b mod p
  =  (g^b)^a mod p            = (g^a)^b mod p
  =  g^(ab) mod p             = g^(ab) mod p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这很抽象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;假设:
p = 23 (素数)
g = 5 (原根)

Alice选择私钥 a = 6
Bob选择私钥 b = 15

Alice计算并发送: A = 5^6 mod 23 = 8
Bob计算并发送: B = 5^15 mod 23 = 19

最终共享密钥:
Alice: 19^6 mod 23 = 2
Bob: 8^15 mod 23 = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者我们构建一个更加通俗的场景&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A B 都搞到了3个杯子&lt;/li&gt;
&lt;li&gt;A这边有两杯数量一致的绿豆 以及一杯黑豆&lt;/li&gt;
&lt;li&gt;B这边有两倍数量一直的红豆(与绿豆数量不同) 以及一杯黑豆(数量是一致的)&lt;/li&gt;
&lt;li&gt;假设为 1,2,3号杯子&lt;/li&gt;
&lt;li&gt;A,B同时操作 将1号杯子的豆子加入3号(黑豆)杯子中&lt;/li&gt;
&lt;li&gt;交换杯子, 将2号杯子倒入3号杯子&lt;/li&gt;
&lt;li&gt;此时 两方得到了一样配比的两个有豆子杯子&lt;/li&gt;
&lt;li&gt;从而得到相同的密钥&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从安全的角度考虑
中间人能看到如下数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;素数p&lt;/li&gt;
&lt;li&gt;原根g&lt;/li&gt;
&lt;li&gt;A发出的g^a mod p&lt;/li&gt;
&lt;li&gt;B发出的g^b mod p&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;无法推算出 双方任何一方的私钥 和最终共同的完整私钥 g^ab /mod p
这里需要够大的素数p 以及定期更换密钥 基本满足安全性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类似还有基于椭圆曲线的 ECDH 密钥交换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般还会双方还会各自生成一个随机数作为因子
交换双方的随机数,双方都有两个,进行密钥的二次加密&lt;/p&gt;
&lt;p&gt;此时 中间人虽然无法对数据进行查阅和修改,但是可以将原本的数据反向传递, A发出我需要一个蛋糕,中间人将数据再次发送给A或者多次发送给B都会造成无法预测的业务混乱.&lt;/p&gt;
&lt;p&gt;因此 一般会对,上面得到的密钥进行第三次处理,拆分为公钥和私钥,避免上面提到的场景.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;TLS1.2&lt;/h2&gt;
&lt;p&gt;上述就是关于 http常见的TLS1.2的简化的握手流程&lt;/p&gt;
&lt;p&gt;这里我们简化了一些可选的 加密过程, mac key 验证数据完整性, iv 加密初始化向量等.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Client                                               Server
   |                                                   |
   |---------------(1) ClientHello--------------------&amp;gt;|
   |                                                   |
   |&amp;lt;--------------(2) ServerHello---------------------|
   |&amp;lt;--------------(3) Certificate---------------------|
   |&amp;lt;-----------(4) ServerKeyExchange------------------|
   |&amp;lt;-----------(5) CertificateRequest(可选)------------|
   |&amp;lt;-----------(6) ServerHelloDone--------------------|
   |                                                   |
   |--------------(7) Certificate(可选)----------------&amp;gt;|
   |-------------(8) ClientKeyExchange----------------&amp;gt;|
   |-------------(9) CertificateVerify(可选)-----------&amp;gt;|
   |-----------(10) ChangeCipherSpec------------------&amp;gt;|
   |--------------(11) Finished-----------------------&amp;gt;|
   |                                                   |
   |&amp;lt;-----------(12) ChangeCipherSpec------------------|
   |&amp;lt;--------------(13) Finished-----------------------|
   |                                                   |
   |==================应用数据传输=======================|
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1. clienthello
- 支持的最高TLS协议版本
- 客户端随机数(Client Random)
- 支持的加密套件列表(Cipher Suites)
- 支持的压缩方法
- 扩展信息
2. serverhello 
- 选择的TLS版本
- 服务器随机数(Server Random)
- 选择的加密套件
- 选择的压缩方法
- 选择的扩展
3. certifcate
- 服务器的证书链
- 包含公钥
- 证书颁发机构(CA)信息
4. serverKeyExchange
- DH或ECDH参数(如果使用)
- 包含签名以防篡改
5. CertificateRequest (可选)
- 要求客户端提供证书
- 指定可接受的证书类型
6. ServerHelloDone
- 表示服务器握手消息发送完毕
7. certificate 客户端证书(可选)
- 如果服务器要求,发送客户端证书
8. clientKeyExchange
- 包含预主密钥(Pre-Master Secret)
- 用服务器公钥加密
9. certificate  可选
- 证明客户端持有私钥
- 对之前所有握手消息的签名
10-12 ChangeCipherSpec
- 通知协商的密钥和加密算法
11-13 finished
- 包含所有握手消息的校验值 
- 协商好的密钥加密

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;预主密钥(Pre-Master Secret)
         ↓
Client Random + Server Random + Pre-Master Secret
         ↓
    主密钥(Master Secret)
         ↓
客户端写密钥  服务器写密钥  MAC密钥  IV
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./file-20241026213301769.png&quot; alt=&quot;https-1.2协议&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;TLS1.3&lt;/h2&gt;
&lt;p&gt;可以看到 复杂度有非常恐怖的提升, 因此 TLS1.3 将流程进行了简化操作.
将所有要传递的加密材料,随机数 合并发送, 使得可以在一个来回建立安全的通信通道.&lt;/p&gt;
&lt;h2&gt;非对称加密不要了?&lt;/h2&gt;
&lt;p&gt;对称加密已经如此强大, 前面的非对称加密是否因此放弃呢? 是的可以放弃
非对称加密首先无法保证绝对的安全, 其次所有的加密内容虽然中间人无法理解但是可以保存,如果服务方内部出现了叛变的情况,那么过去保存的数据就全部遭到了破解,不具备前向保密性.&lt;/p&gt;
&lt;p&gt;解决方式 就是使用动态的密钥, 前面曾经提到 非对称加密的时间复杂度更高,因此使用相对更少.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;至此,TLS 完成了对于HTTP协议的加密, 也就是现在常用的 HTTPS&lt;/p&gt;
&lt;h2&gt;HTTP1.0&lt;/h2&gt;
&lt;p&gt;我们回到 HTTP协议本身 ,如果客户目前有多个访问请求给到服务器, 这产生了一个问题就是每个请求是独立的 便会产生多个TCP协议,反复的创建和销毁TCP套接字产生了不必要的资源消耗.&lt;/p&gt;
&lt;h2&gt;HTTP1.1&lt;/h2&gt;
&lt;p&gt;为了避免反复的创建套接字,HTTP1.1 的版本中引入了一个 keep_alived的机制, 使得不必反复创建套接字,而是共同获取资源使用共同的套接字资源.&lt;/p&gt;
&lt;p&gt;1.1版本在请求上也做到了优化,允许多个请求同时发起,而不必等到响应;
但是引入了一个新的问题, 每个请求的返回结果所占字节可能不同, 后一个可能由于前一个的阻塞导致迟迟不能到达,产生体验上的不畅.&lt;/p&gt;
&lt;h2&gt;HTTP2&lt;/h2&gt;
&lt;p&gt;为了避免1.1的阻塞情况, 2的版本引入了拆包的概念,数据到达后进行重组,这样优化了小数据的到达速度,减少了数据的等待情况.&lt;/p&gt;
&lt;p&gt;这里对于数据的拆包, 依据的原则是将头部帧和数据帧拆分,由于多个网页的请求头部数据高度一直,头部帧的内容往往不需要全部的传递而是可以复用, 那么建立头部索引表,就可以大大降低了时间的消耗.&lt;/p&gt;
&lt;p&gt;至此的HTTP和HTTP2 底层实现都是TCP实现,TCP 自身为了保证自己的面向连接的安全性有序列号和确认号的机制,因此 这两个大版本的HTTP都无法解决 头部阻塞引起的整体阻塞的情况.&lt;/p&gt;
&lt;h2&gt;HTTP3&lt;/h2&gt;
&lt;p&gt;HTTP3中为了摆脱TCP产生的阻塞问题, 优化了底层栈实现, 改用谷歌公司开发的 QUIC协议实现, QUIC的底层是UDP实现
&lt;img src=&quot;./file-20241026174241414.png&quot; alt=&quot;迭代架构变更&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里看到TLS1.3直接嵌入到了 QUIC中 因此也是一个来回的数据传递 就可以建立连接+TLS握手&lt;/p&gt;
&lt;p&gt;从实际情况考虑, HTTP2 仍然还是协议使用的主流,可能是如下原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UDP可能被防火墙封堵&lt;/li&gt;
&lt;li&gt;故障排查工具不完善&lt;/li&gt;
&lt;li&gt;性能监控方案不成熟&lt;/li&gt;
&lt;li&gt;部分中间件(nginx, haproxy) CDN等 支持有限&lt;/li&gt;
&lt;li&gt;对老的客户端环境的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑到篇幅, 部分协议细节有所缺失,感兴趣可以自行查阅:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS 缓存机制 TTL 记录类型等&lt;/li&gt;
&lt;li&gt;HTTP 的请求方法区别 GET POST PUT等 常见状态码表达的意思&lt;/li&gt;
&lt;li&gt;TLS Session复用机制&lt;/li&gt;
&lt;li&gt;HTTP2 多路复用&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;其中几个主题也可以展开实践,后续可能深入讨论.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络性能优化实践&lt;/li&gt;
&lt;li&gt;HTTPS部署最佳时间&lt;/li&gt;
&lt;li&gt;常见网络问题排查案例&lt;/li&gt;
&lt;li&gt;网络安全实践指南&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</content:encoded></item></channel></rss>